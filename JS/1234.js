'use strict'

// // Область видимости переменных 
// let a = 100
// let b = 200

// function test() {
//     let a 
//     a = 10
//     // b = true      // изменит переменную в глобальной области видимости  
//     console.log(a)   // 10
//     console.log(b)   // 200    // возьмет значение глобальной переменной
// }

// test()
// console.log(a)      // 100
// console.log(b)      // 200
// // ----------------------------------------------------------------------------------


// // цепочка областей видимости
// let a = 10

// function myFn() {
//     function innerFn() {
//         // a = 30
//         console.log(a)     // 10
//     }
//     innerFn()              // тут просто вызываем функцию внутри другой что бы она сделала вывод в консоль
// }
// // innerFn()               // error      // при таком вызове вункции будет ошибка т.к. переменной innerFn мы объявили в локальной области видимости и нет доступа к ней из глобальной области.
// myFn() 
// // console.log(a)
// // -------------------------------------------------------------------------------------


// // жизненный цикл переменных 
// let a
// let b 

// function myFn() {
//     let b
//     a = true
//     b = 10
//     console.log(b)      // 10
// }

// myFn()

// console.log(a)          // true
// console.log(b)          // undefined
// // -------------------------------------------------------------------------------------


// // логические операторы

// // оператор ! (НЕ) всегда возвращает bolean значение 
// let operOtr = ''
// console.log(!!operOtr)     // false

// // выражение1 && выражение2     (И) возвращает первое ложное значение, остальное игнорируется, если не нашлось, то возвращает последнее выражение 
// console.log(4-4 && 2)     // 0

// // выражение1 || выражение2     (ИЛИ) возвращает первое истинное значение, остальное игнорируется, если не нашлось, то возвращает последнее выражение 
// console.log(4-1 || 2)     // 3
// console.log(4-4 || 2 || console.log('выполнено') || 0)   // 2   // тут видим, что при работе интерпритатор не доходит до выражения вывода в консоль
// // -------------------------------------------------------------------------------------


// // оператор разделения объекта на свойства  ( ...(объект)) только первый уровень вложенности

// const button = {
//     width: 200,
//     text: 'buy',
//     color: 'green',     
// }

// const redButtonV1 = {
//     ...button,
//     color: 'red'            // посторяющиеся значение будет перезаписано
// }

// const redButtonV2 = {
//     color: 'red' ,          // посторяющиеся значение не будет перезаписано
//     ...button
// }

// console.log(button)               // { width: 200, text: 'buy', color: 'green' }
// console.log(redButtonV1)          // { width: 200, text: 'buy', color: 'red' }
// console.log(redButtonV2)          // { color: 'green', width: 200, text: 'buy' }

// const coppyButton = {...button}   // тут создали копию объекта, но только на первом уровне вложенности
// console.log(coppyButton)          // { width: 200, text: 'buy', color: 'green' }

// const union = {                     // объединение объектов. только первый уровень вложенности
//     ...button,
//     ...redButtonV1                // порядок влияет на перезапсь свойств в объектах. (ведхний удалитьс, нижний сохраниться)
// }
// console.log(union)                // { width: 200, text: 'buy', color: 'red' }

// // -------------------------------------------------------------------------------------


// // Шаблонные строки ( ``  обратные кавычки)  в ${любое выражение}

// const myName = 'Павел'
// const city = 'Рязан'
// const aboutMe = `Меня зовут ${myName}, я живу в  ${city}и`
// console.log(aboutMe)    // Меня зовут Павел, я живу в  Рязани

// // -------------------------------------------------------------------------------------


// //  обявленная функция или функциональное выражение (анонимная функция)

// function myFn (a, b) {
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// console.log(myFn(10, 5))    // 16

// const myFnV1 = function(a, b) {        // присвоили функциональное выражение переменной. преимущество присвоения анонимной функции константе в том, что ее нельзя случайно переназначить
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// console.log(myFnV1(1, 3))    // 5       // передаем аргументы для функции в переменную в скобках 

// setTimeout( function() { console.log('колбек функция') }, 2000)         // функциональное выражение (анонимная функция) в другой функции

// // -------------------------------------------------------------------------------------


// // стрелочные функции,  является выражением, всегда анонимные, преимущество присвоения анонимной функции константе в том, что ее нельзя случайно переназначить

// const myFn = (a, b) => {             // тут стрелочную функцию присвоили переменнной.  
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// console.log(myFn(2, 5))         // 8

// setTimeout(() => {console.log('стрелочная функция колбек')}, 2000) 

// const test = (a, b) => a + b    // стрелоч. функц. с одним выражением  возможно убрать фигурные скобки, но тогда она вернет результат этого выражения (return не явно указан) 
// console.log(test(2, 4))         // 6

// // -------------------------------------------------------------------------------------


// //  значения параметров функции по умолчанию

// // в примере создаем копию объекта и прибавляем время когда функкция отработала с помощью вставки параметра по умолчанию 
//         // // ниже не явно возвращаем объект из функции  . тут синтаксис ({})
//         // тут нужно разобраться https://www.youtube.com/watch?v=CxgOKJh4zWE&t=36944s      5.01.48 время
//         // const newPost = (post, addedAd = Date()) => ( {
//         //     ...post,
//         //     addedAd,
//         // } )

// const postMessage = {
//     title: 'сообщение',
//     text: 'привет, я текст',
// }

// function newPost (post, addedAd=Date()) {
//     return {
//         ...post,
//         addedAd: addedAd,   // или сокраащенно addedAd, т.к. имя в создаваемом объекте не захотели изменять
//     }
// }

// const newPostMessage = newPost(postMessage)
// console.log(newPostMessage)           //{ title: 'сообщение',text: 'привет, я текст', addedAd: 'Mon Mar 18 2024 12:10:58 GMT+0300 (Москва, стандартное время)' }
// // -------------------------------------------------------------------------------------


// // обработка ошибок   при таком методе код не останавливается
// const fnWithError = () => {
//     throw new Error('моя ошибка') // тут искуственно гененрируем ошибку
// }

// try{
//     fnWithError()
// } catch (error) {
//     console.error(error)
//     console.log(error.message)
// }

// console.log('продолжить')
// // -------------------------------------------------------------------------------------


// Инструкции выражения  как отличить
// выражения можем подставить как аргументы в функции. это код, который после выполнения возвращает какое-либо значение. Например, 5 + 3
// инструкции не можем подставить как аргументы в функции. в конце ставим ; это отдельная команда в коде, которая выполняет определённое действие. Например, if
// function myFn(a) {
//     console.log(a)
// } 


// массивы 
// const myArray1 = [1, 2, 3] 
// console.log(myArray1)    // myArray1 не равно myArray2  хоть и внешне одинаковы. но это тоже объекты и переменные содержат ссылки на место в памяти  

// const myArray2 = new Array(1, 2, 3)
// console.log(myArray2)