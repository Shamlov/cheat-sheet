'use strict'

// // Область видимости переменных 
// let a = 100
// let b = 200

// function test() {
//     let a 
//     a = 10
//     // b = true      // изменит переменную в глобальной области видимости  
//     console.log(a)   // 10
//     console.log(b)   // 200    // возьмет значение глобальной переменной
// }

// test()
// console.log(a)      // 100
// console.log(b)      // 200
// // ----------------------------------------------------------------------------------


// // цепочка областей видимости
// let a = 10

// function myFn() {
//     function innerFn() {
//         // a = 30
//         console.log(a)     // 10
//     }
//     innerFn()              // тут просто вызываем функцию внутри другой что бы она сделала вывод в консоль
// }
// // innerFn()               // error      // при таком вызове вункции будет ошибка т.к. переменной innerFn мы объявили в локальной области видимости и нет доступа к ней из глобальной области.
// myFn() 
// // console.log(a)
// // -------------------------------------------------------------------------------------


// // жизненный цикл переменных 
// let a
// let b 

// function myFn() {
//     let b
//     a = true
//     b = 10
//     console.log(b)      // 10
// }

// myFn()

// console.log(a)          // true
// console.log(b)          // undefined
// // -------------------------------------------------------------------------------------


// // логические операторы

// // оператор ! (НЕ) всегда возвращает bolean значение 
// let operOtr = ''
// console.log(!!operOtr)     // false

// // выражение1 && выражение2     (И) возвращает первое ложное значение, остальное игнорируется, если не нашлось, то возвращает последнее выражение 
// console.log(4-4 && 2)     // 0

// // выражение1 || выражение2     (ИЛИ) возвращает первое истинное значение, остальное игнорируется, если не нашлось, то возвращает последнее выражение 
// console.log(4-1 || 2)     // 3
// console.log(4-4 || 2 || console.log('выполнено') || 0)   // 2   // тут видим, что при работе интерпритатор не доходит до выражения вывода в консоль
// // -------------------------------------------------------------------------------------


// // оператор разделения объекта на свойства  ( ...(объект)) только первый уровень вложенности

// const button = {
//     width: 200,
//     text: 'buy',
//     color: 'green',     
// }

// const redButtonV1 = {
//     ...button,
//     color: 'red'            // посторяющиеся значение будет перезаписано
// }

// const redButtonV2 = {
//     color: 'red' ,          // посторяющиеся значение не будет перезаписано
//     ...button
// }

// console.log(button)               // { width: 200, text: 'buy', color: 'green' }
// console.log(redButtonV1)          // { width: 200, text: 'buy', color: 'red' }
// console.log(redButtonV2)          // { color: 'green', width: 200, text: 'buy' }

// const coppyButton = {...button}   // тут создали копию объекта, но только на первом уровне вложенности
// console.log(coppyButton)          // { width: 200, text: 'buy', color: 'green' }

// const union = {                     // объединение объектов. только первый уровень вложенности
//     ...button,
//     ...redButtonV1                // порядок влияет на перезапсь свойств в объектах. (ведхний удалитьс, нижний сохраниться)
// }
// console.log(union)                // { width: 200, text: 'buy', color: 'red' }

// // -------------------------------------------------------------------------------------


// // Шаблонные строки ( ``  обратные кавычки)  в ${любое выражение}

// const myName = 'Павел'
// const city = 'Рязан'
// const aboutMe = `Меня зовут ${myName}, я живу в  ${city}и`
// console.log(aboutMe)    // Меня зовут Павел, я живу в  Рязани

// // -------------------------------------------------------------------------------------


// //  обявленная функция или функциональное выражение (анонимная функция)

// function myFn (a, b) {
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// console.log(myFn(10, 5))    // 16

// const myFnV1 = function(a, b) {        // присвоили функциональное выражение переменной. преимущество присвоения анонимной функции константе в том, что ее нельзя случайно переназначить
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// console.log(myFnV1(1, 3))    // 5       // передаем аргументы для функции в переменную в скобках 

// setTimeout( function() { console.log('колбек функция') }, 2000)         // функциональное выражение (анонимная функция) в другой функции

// // -------------------------------------------------------------------------------------


// // стрелочные функции,  является выражением, всегда анонимные, преимущество присвоения анонимной функции константе в том, что ее нельзя случайно переназначить

// const myFn = (a, b) => {             // тут стрелочную функцию присвоили переменнной.  
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// console.log(myFn(2, 5))         // 8

// setTimeout(() => {console.log('стрелочная функция колбек')}, 2000) 

// const test = (a, b) => a + b    // стрелоч. функц. с одним выражением  возможно убрать фигурные скобки, но тогда она вернет результат этого выражения (return не явно указан) 
// console.log(test(2, 4))         // 6

// // -------------------------------------------------------------------------------------


//