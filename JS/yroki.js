// shift + enter используется для переноса курсора на новую строку в консоли без  выполнения кода

let str = '      прИвЕтИкИ    '
console.log(str.trim()[0].toUpperCase() + str.toLowerCase().trim().slice(1))   // убираем пробелы и приводим в четабельный вид строку 

undefined  // переменная не определена
null       // пустое значение
NaN        // не число. тип 'Number'. NaN не равно ничему даже самому себе. проверка Number.isNaN() или  isNaN() возвращает булевое значение

console.log(true && true)   // логическое и    преобразует в логическое значение и возвращает первое истинное значение, если операнды ложные то возвращает последний операнд (даже если истина)
console.log(true || false)  // логическое или  преобразует в логическое значение и возвращает первое ложное значение, если ничего не найдено возвращает последнее 
console.log(!true)          // логическое отрицание  преобразует в логическое значение и возвращает противоположное логическое значение
//Приоритет операторов   ! (не)   && (и)   || (или)        двойное (НЕ) !! используют для преобразования значений к логическому типу  !!'не пустая строка'

//---------------------------------------------------МАССИВЫ---------------------------------------------------------------------------------------------------------
const array = [12, false, 'элемент массива', [[2, 4, 13], [43, false, true], ['массив в массиве', 'тест']]]     // массив
const myArray1 = new Array(1, 2, 3)         // тоже массив но записывается иначе.
const myArray2 = [1, 2, 3] myArray1 == myArray2    // false т.к. массив это объект и переменная хранит ссылку на разные объекты, поэтому они не равны 
const myArray3 = myArray2  myArray3 == myArray2    // true т.к. сравниваем ссылки на один и тот же массив
console.log(array)                 // выведет маммив полностью
array.length                       // используя точечную запись, можно прочитать свойство длинны массива. 
console.log(array[0])              // дает значение элемента массива . так обращаемся к свойствам массива. т.к. массив это объект, а к цифровым свойствам объекта обращаються через []
console.log(array[3][2][0])        // обращение к массиву в массиве
console.log(array[5])              // вызвали не существующий элемент массива и получили undefined 
array[2] = ['измененный элемент']  // меняем значение элемента
array[6] = ['добавление в масив']  // добавление элемента, тут пропустили очередность в массиве . свободные ячейки приняли значение undefined.  длинна пересчиталась по последнему (увеличилась)
array.  // написав в браузере (массив.) мы увидем список всех методов доступных для массива  доступных на уровне Prototype. ниже рассмотрим основные
array.push(добавляемое значение)       // добавление в конец массива.возвращает новую длину массива
array.shift()    // ИЗВЛЕКАЕМ начальный(нулевой) элемент массива.функция вернет значение этого элемента, а элемент исчезнет из массива.вызывается без аргументов. (массив пересчитывается и на это требуется ресурсы процессора)
array.pop()      // ИЗВЛЕКАЕМ последний элемент массива.функция вернет значение этого элемента, а элемент исчезнет из массива. вызывается без аргументов.
array.unshift(добавляемое значение)     //добавление в начало массива. возвращает новую длину массива. внимание массив пересчитывается. возвожна сложность с огромными массивами
array.concat(добавляемый массив)       // конкатинация(склеивание) массивов.возвращает склеенный массив
array.indexOf(значение искомого элемента)     // возвращает индекс ПЕРВОГО совпавшего элемента. не ищет в массиве вложенниом в другой массив. возвращает -1 если элемент не найден               
array.join('')    //превращает массив в строку.значение в скобках это символ между элементами.пустая строка то все элементы склеиваются, если запятая то получим строку с элементами через запятую
array.splice(с какого индекса начинаем измеенять, колличество изменяемых элемент, эл1, эл2....элN)    //изменяет содержимое массива удаляя существующие элементы и / или добавляя новые.принимает, возвращает массив из изятых элементов.меняет массив выше по коду.поддерживает отрицательные индексы массива(-2 например) т.е.отсчет с конца - 1 предпоследний элемент
array.slice(начало, конец(не включая))  //возвращает массив элементов от указанного индекса до указанног индекса не включая его.поддерживает отрицательные индексы(отсчет с конца массива)
array.includes(искомый элемент)  // выполняет поиск по массиву и позвращает булевое значение true / false.чувствителен к регистру
array.reverse()   //возвращает массив в обратном порядке
array.forEach((elem, индекс опционально) => console.log(elem * 2))   // перебирает все элементы массива и для каждого элемента будет вызывать колбек функцию которую записали в скобках. не мутирует оригинальный массив. сам метод ниего не возвращает (undefined)
array.map((elem) => elem * 2)       // перебирает все элементы массива и для каждого элемента будет вызывать колбек функцию которую записали в скобках. не мутирует оригинальный массив. сам метод возвращает новый массив, если например присвоить метод новой переменной. ВАЖНО что бы колбек функция (которую передали в скобках) явно или не явно возвращала зачение которое запишется в новый массив.
'привет, дом, 43, союз'.split('разделитель в примере запятая и пробел. по разделителю делят элементы массива')     // преобразует строку в массив
'привет'.split('')  // получим массив из букв данной строки
//==================================================================================================================

//-----------------ДЕСТРУКТУРИЗАЦИЯ------создаем переменные и присваиваем значения на основании свойств объекта------------------------------------------------------------------------------------
const obj = {                // деструктуризация объектов
	myName: 'Pavel',
	age: 35,
	man: true,
}
const { myName, age } = obj  // conct или let, var {имена свойств обекта(запятая),} = из какого обекта достаем       тут получаем переменную myName = 'Pavel' и т.д.
console.log(myName)          // Pavel    создалась переменная с именем из объекта и значением из объекта

const massive = [ 14, true, 'Pavel' ]   // деструктуризация массивов
const [ oneElem,  twoElem ] = massive   // conct или let, var [ придумываем имена новых переменных в нужном порядке ] = из какого массива достаем    тут получаем переменную oneElem = 14 и т.д.
console.log(twoElem)  // true              значения переменным присваиваются по порядку следования элементов в массиве

const userInfo = function ({myName, age}) {    // диструктуризация в функциях   внутри () диструктуризация параметров функции
    if (age < 18) {                            // создаются переменные внутри функции(const let не нужно указывать), ищются свойства в объекте по названию (myName, age), им присваиваются значения согласно объекта. п 
        return console.log(`${age} меньше положенного`)
    }
    return console.log(`${myName} твой возраст ${age} `)
}
userInfo(obj)    // тут в функцию передаем объект. в блоке парасетров () выполняем диструктуризацию объекта
//==================================================================================================================

//-------------------------------------------УСЛОВИЯ----------------------------------------------
//Число 0, пустая строка "", null, undefined и NaN    становятся false.

let age3 = prompt('какой ваш возраст')
if (age3 != null) {                       // в скобках условие, которое должно возвращать булевое значение.
	alert('мой возраст ' + age3)		  // в {} инструкция выполняемая однократно если в () при приведении к булевому значению будет true.  т.е. число или строка вернут true 
} else {							 	  // else выполнет блок кода один раз если условие выше ложно.
	alert('вы нажали отмену')             // выполнится или один, или другой блок кода.
}

let age1 = prompt('введите возраст')
if (age1 <= 0) {                              // в скобках условие, которое должно возвращать булевое значение.   
	alert('вашвозраст равен или меньше 0')	  // в {} инструкция выполняемая однократно если в () при приведении к булевому значению будет true.  т.е. число или строка вернут true 
} else if (age1 < 18) {						  // добавляем еще условаие для проверки. 
	alert('мой возраст меньше 18')
} else if (age1 == 18) {				      // как только одно из условий даст true, выполниться блок кода и условия ниже даже не будут просмотрены интерпритатором
	alert('ВАм 18 лет')
} else if (age1 > 18) {
	alert('вам больше 18 лет')
} else {                                      // else выполнет блок кода один раз если все выше перечисленные условия ложны.
	alert('вы ввели текст')
}

const myFn = (a) => {              // условия в функциях. функция остановиться при return в любом месте
    if(a > 10) {				   //  нет особого смысла использовать if else   но делать так можно
        return a = a + 10          // если тут условие истино, тогда будет событие return и функция остановиться
    } 
    if (a > 20) {
        return a = a + 100         // return может быть в каждой проверке если это необходмио опционально 
    } 
    return a * 320
} 

let age2 = 18
switch (true) {                               // может быть не только true . в () происходит строгое сравнение === например можно сравнивать с числом 3
	case age2 >= 18:                          // это строго сравниваем === с выражением в ()
        console.log('больше или равно 18')
		// break;							  // если не писать break, тогда код ниже выполниться но условия сравниваться не будут 
	case age2 == 18:
		console.log('18')
		// break;
	case age2 < 18:
		console.log('меньше 18')
		break;                                // если не писать break, тогда код ниже выполниться но условия сравниваться не будут. до ближайшего break
	default:                                  // аналог else , если ни одно из условий не совпало
        console.log('не число')
}

// условаие ? выражение1 : выражение2    // тернарный оператор, является выражением(возвращает значение) т.е. вернет РЕЗУЛЬТАТ выражения1 или  выражения2 в зависимости от условия. 
// в условии пишем любые выражения и затем они автоматически конвертируются в булевое значение. если true тогда возвращается выражения1, если fulse вернет выражение2. 
// результат одного из выражений будет возвращен(можно записать в переменную). можно использовать только выражения (не инструкции if for и пр.)  

const value = 0
value ? console.log('условие истино') : console.log('условие ложно')   // это выражение инструкция ,  мы не присваиваем ничему значение. просто выполним действия.  но и тут все это выражение вернет undefined . т.к. console.log()  возвращает undefined
console.log(value ? console.log('условие истино') : console.log('условие ложно')  )

const value1 = 23
const value2 = 43
value1 && value2 ? myFunction1(value1, value2) : myFunction2()    // в варажения можем подставлять функцию, тут если любое из числел не 0, тогда выполниться myFunction1(value1, value2)

const value4 = 30
let rez = (value4 >= 10 ? value4 + 10 : value4 + 100)       // тут непосредственно возвращаем результат выражения. например можно присвоить переменной
console.log(rez)     // 40
//==================================================================================================================

//------------------ ЦЫКЛЫ-----всегда инструкции------------------------------------------------------------

for(начальная инструкция ; условие (true false); итерационное действие) {
    выполняемый блок кода на каждой итерации
}

for(let i = 0; i < 11; i = i + 2) {     // вводим переменную i и присваиваем ей значение; пишем условие которое проверяем, если истино(true) то выполняем код. далее выполняем в блок i = i + 2
	console.log(i)                      // в данно примере выведем четные числа  i = i + 2
}
// из () можно убирать любую част синтаксис(;i < 11;) не забывать ; . можно воспользоваться внешней переменной. можно итерационное действие выполнить в цикле
// for не рекомендуется использовать в массивах, используй forEach map reduce и т.д.

while () {                                      // пока (true) цикл выполняется. 
    блок кода выполняемый на каждой итерации    // если (false) тогда цикл не выполниться ни разу (интерпритатор не зайдет в цикл)
}

let count = 0
while (count < 9) {                   // сперва проверяет условие -> затем выполняет код {}   пока условие истино(true) цикл выполняется
	if (count == 4) {                 // внутри цикла возможно ввести еще условие
		break                         // досрочно завершаем цикл
	}
	count++                           // тут изменяем значение переменной котороя влияет на условие, иначе цикл будет бесконечный
	console.log(count);
}

do {                                               // если (false) тогда цикл ВЫПОЛНИТЬСЯ один раз
	блок кода выполняемый на каждой итерации	   // сперва выполняем блок кода, затем проверяем условие
	break                                          // если нужно выйти из цикала.  break должен стоять в этой части кода
} while ()                                         // пока (true) цикл выполняется. 

let count1 = 0
do {                               // сперва выполняет один цикл и далее проверяет условие
	console.log(count1)
	count1++
} while (count1 < 9)               // пока условие истино(true) цикл выполняется

for(key in obj) {                         // циклы в объектх. в созданную нами переменную key1 поочередно передаются имана(ключи) обектов. не использовать в массивах
действия с каждым свойством объекта       // создается переменная key , в нее каждый цикл записывается свойство(ключ)
получить знаачения свойства - obj[key]    // зная имена (ключи) обекта получаем возможность обращаться к значениям и производить вычисления
}
// циклы в обектах
const obj1 = {
	name: 'Ivan',
	age: 36,
	number1: 23687
}

for (let key1 in obj1) {           // циклы в объектх. в созданную нами переменную key1 поочередно передаются имана(ключи) обектов. не использовать в массивах
	console.log(key1)              //это основное применение цикла , перебор имен(ключей) они передаются в переменную key1 её создаем сами. соответственно зная имя можем делать все
	console.log(obj1[key1])        // зная имена (ключи) обекта получаем возможность обращаться к значениям и производить вычисления  [] так обращаемся к значению объекта если используем в имени переменную(тут key1)
	console.log(`ключ ${key1}  значение ${obj1[key1]}`)     // как пример
}
Object.keys(obj1).forEach((key1) => console.log(key1, obj1[key1]) )  // Object.keys   этим методом получаем все КЛЮЧИ объекта в виде массива. т.е.Object.keys(obj1) это массив и .forEach((key) перебираем элементы уже массива
Object.values(obj1).forEach((value1) => console.log(value1) )  // Object.values   этим методом получаем все ЗНАЧЕНИЯ объекта в виде массива. т.е.Object.values(obj1) это массив и .forEach((obj1) перебираем элементы уже массива

// циклы в массивах рекомендуется делать так  . //  for не рекомендуется использовать в массивах, используй forEach map reduce и т.д.
const myArray2 = [1, 2, 3]
array.forEach((elem, индекс опционально) => console.log(elem * 2))   // перебирает все элементы массива и для каждого элемента будет вызывать колбек функцию которую записали в скобках. не мутирует оригинальный массив. сам метод ниего не возвращает (undefined)
array.map((elem) => elem * 2)          // перебирает все элементы массива и для каждого элемента будет вызывать колбек функцию которую записали в скобках. не мутирует оригинальный массив. сам метод возвращает новый массив, если например присвоить метод новой переменной. ВАЖНО что бы колбек функция (которую передали в скобках) явно или не явно возвращала зачение которое запишется в новый массив.

for (const key1 in myArray2 ) {        // обявляем переменную с помощью const (возможно можно let). key1 будет индексом массива. myArray2 - массив который перебираем
	console.log(key1, myArray2[key1])  // for не рекомендуется использовать в массивах, используй forEach map reduce и т.д.
}

for( elem of iterable) {                      // iterable  любой элемент который можно перебирать. обычно его записывают в переменную
	// действия с определенным элементом      // в elem записывается каждый отдельный элемент из итерируемого элемента
	}
	
	const string1 = 'Привет'          // строка перебирается посимвольно
	for(const elem1 of string1) {     // const т.к. каждый раз создается новая переменная (можно let)
		console.log(elem1)            // действия c элементом.  итог каждый символ получим отдельно
	}
	
	const myArray5 = [3, true, 'abc', null]    // каждый элемент будем получать в переменную elem2
	for(const elem2 of myArray5) {             // onst т.к. каждый раз создается новая переменная (можно let)
		console.log(elem2)                     // получим каждое значение массива отдельно. тут строка по символам не разобьется
	}                                          // для массива ЛУЧШЕ ИСПОЛЬЗОВАТЬ forEach , но можно и этот
	
// !! for of НЕ ПОДОЙДЕТ для ОБЪЕКТА . это не итерирумый элемент. Будет ошибка  используй for in или конвертируй в массив Object.keys  или  Object.values 
//==================================================================================================================



fgbfd
fjyyuiu
jyfuuizsfgrdh
hug bvy biu





































//-----------------------------------------------ОБЪЕКТЫ------------------------------------------------------------------------------------------
//https://www.youtube.com/watch?v=fcMcf_4PjfI&t=21318s     5.25
// после кажного обекта запятая. даже на посленнем элементе(висящая)
const person = {
	name: 'pavel',
	age: 36,
	zhenat: true,
	lang: ['ru', 'en'],                // массив внутри объекта
	address: {                         // возможно создать объект внутри объекта
		city: 'Zaraisk',
		street: 'Novaya',
	},
	'complex key': 'complex',            // если требуется написать ключ из нескольких слов с пробелом
	[1 + 2]: 'computed',                 // вычисляемый ключ
	[new Date().getTime()]: 'computed',  // массив внутри объекта
	greet() {                                            // анонимная функция в объекте   person.greet()  таким образом можем ее вызвать
		console.log('анонимная Функция в объекте')        // есть возможность просто вызвать функцию в объекте без (ключ:значение)
		console.log(this)                                 // если при классическом обявлении функции в консоле посмотреть this, то видим, что он относится к этому объекту
	},
	arrow: () => {                                     // стрелочная функция в объекте    person.arrow() так можем ее вызвать 
		console.log('Стрелочная Функция внутри объекта' + ' ' + this.name)  // в функции внутри объекта возможно обращаться к элементам этого объекта.  
		console.log(this)                               // в стрелочной функции видим, что this не ссылается на этот объект, а ссылается на window  (не создает свой контекст и не перенимает контерст текущего объекта, а принимат более глобальный контекст)
	},
	info() {                              // есть возможность просто вызвать функцию в объекте без (ключ:значение)
		console.log('Функция внутри объекта' + ' ' + this.name)           //  this вместо (person.name). this внутри объекта обращается к элементам этого обекта. и если имя объекта изменить то с this все будет работать
		console.log(this)                  //  когда обращаемся к this внутри функции или класса то мы как бы обращаемся к этому объекту не обращая внимания на имя всего объекта. при смене имени объекта функции внутри продолжат работу
	}
}

person.age = 35                             // так меняем значение 
console.log(person.name)                    // таким способом получаем ключи объекта
console.log(person['complex key'])          // так же получаем ключ обекта в том числе состоящий из нескольких слов с пробелом
console.log(person)                         // показывает массив полностью
const addressKey = 'address'                //  можно создать переменную с именеи из объекта  
console.log(person[addressKey])             //  тут можно обратиться к имени в оъекте через переменную . работает только сквадратными скобками 
person.greet()                              // есть возможность просто вызвать функцию в объекте без (ключ:значение)
person.info()                               // вызов функции находящийся внутри объекта 
person.arrow()                              // в стрелочной функции видим, что this не ссылается на этот объект, а ссылается на window  (не создает свой контекст и не перенимает контерст текущего объекта, а принимат более глобальный контекст)
// значения в объектах можно менять добавлять и удалять
person.age++                                // изменили возраст на 1 вверх
person.lang.push('de')                      // обратились по пути и (с помощью push т.к это массив) добавили данные
console.log(person.lang)                    // проверяем что данные добавились в массив
delete person.zhenat                        // удаляем имя и значение из объекта
//деструктуризация  это получение значений или имен обекта в переменную но с коротким и удобным синтаксисом
// (закоментировано т.к. ниже пример с такимиже именами констант)const { name, age, lang } = person         // тут получаем 3 констаны из объекта person со значениями. имена констант соответственно совпадают с ключами. если такие нонстанты уже есть тогда будет ошибка и необходимо применять иной способ
const { name: firstName, age = 45, lang } = person      //   тут положи в КОНСТАНТУ firstName значение из person и имени name. соответственно можем создавать константы уже с любыми именами. если значение не задано (отсутствует или =undefined)в объекте то возможно задать по умолчанию напримет возраст 
console.log(firstName, age, lang)               // проверяем созданные константы в консоли 

for (let key in person) {                      // итерации по ключам и значениям объекта. создаем переменную key и в нее помещаем имена из обекта person 
	if (person.hasOwnProperty(key)) {           // тут добавляем (hasOwnProperty) проверку для получения только собственных ключей и соответственно значений, т.к. обычный цикл идет и по портотипам 
		console.log(key)                         // тут видим имена(ключи)
		console.log(person[key])                 // тут подставляя ключи получаем значения из объекта
	}
}

const keys123 = Object.keys(person)            // метод получения ключей(имен) объекта в виде массива с помощью Object.keys (не затрагивает цепочку портатипов объекта)
console.log(keys123)                           // ключи объекта в массиве

keys123.forEach((key) => {                      // Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.
	console.log(person[key])                    // получаем значения для каждого элемента (ключа) объекта
})

Object.keys(person).forEach((key) => {         // тут мы сократили лишнюю переиенную и keys123  и записали напрямую. т.к. она просто взвращает массив имен. даллеперебрали с помощью метода forEach()
	console.log(person[key])
})
// работа с this с помощью метода bind() мы получим доступ к любому массиву и будем работать с функциями из массива logger1
const logger1 = {
	keys1() {
		console.log('ключи объекта', Object.keys(this))      // Object.keys     с заглавной буквы     получаем массив имен объекта
	},

	klychiIZnacheniya() {
		Object.keys(this).forEach((key) => {
			console.log('klych ', key)                         //получаем ключи
			console.log('znachenie ', this[key])               // получаем значение 
		})

	}
}

const test1 = logger1.keys1.bind(person)          //   метод bind() проверяем в консоли    
test1()                                           // тут в скобки можно передавать параметр в данном случае keys1(вот сюда упадет параметр)
const test2 = logger1.klychiIZnacheniya.bind(person)          // проверяем в консоли
test2()
logger1.klychiIZnacheniya.bind(person)()          //  такая запись тоже самое что и выше но встречается чаще .т.е. в строке сразу вызываем функцию    проверяем в консоли 

const test3 = logger1.keys1.call(person)          //  метод call()   отличия от bind() в том что он сразу вызывается. не нужно добавлять скобки в конце(вызывать)          проверяем в консоли
logger1.keys1.call(person)                        // logger1.keys1.call(person, параметр1, параметр, ....) вариант записи без переменной (тут параметры будут из обекта keys1(вот сюда встает этот параметр))
logger1.keys1.apply(person)                      // logger1.keys1.apply(person, [пар1, пар2, ...])   тоже самое что и call но параметры является массив

obj[переменная]   - так обращаемся к значению объекта если используем в имени переменную




//----------------------------------------------------------------ФУНКЦИИ--------------------------------------------------------------------

function printText(name2, age2) {                                             // Function Declaration Объявление функции. можем вызывать функцию выше по коду(функции в таком виде "Всплывают")  (name2, age2) называют параметры функции , а когда вызываем функцию эти данные называются аргументы
	console.log(`меня зовут ${name2} мой возраст ${age2}`)                     // при создании функции продумывать какие параметры будут обязательны (вначале пишем их) а какие  опциональные. это нужон если параметр не передадут (обязатель, обязательный, опция можно не передавать)
	return `меня зовут ${name2} мой возраст ${age2}`                           // тут мы возвращаем значение в функцию. в данном примере printText
}

const printText2 = function (name2 = 'антон', age2 = 45) {                     // function expression сразку присваиваем анонимную функцию переменной(константе). функцию нельзя вызывать до ее объявления. не всплывает. можем передавать значения по умолчанию. 
	console.log(`меня зовут ${name2} мой возраст ${age2}`)                     // в параметры по умолчанию мозможно вычислять (age = 18, sam = age*2)
	return `меня зовут ${name2} мой возраст ${age2}`                           // return слово которое останавливает выполнение функции (ниже код не выполняется) и записывает это значение в имя функции   тут мы возвращаем значение в функцию. в данном примере printText
}

const printText3 = (name2 = 'антон', age2 = 45) => console.log(`меня зовут ${name2} мой возраст ${age2}`)        // arrow function стрелочная функция. если 1 действие пишем в строку без{} return не пишем. ставиться по умолчанию. если несколько действий в ыункции тогда ставим {} пищем как и в обычной функции каждое действие с новой строки и вконце обязательно пишем return если требуется. т.к. по умолчанию он не ставиться . нет параметра "arguments" . не создают свой собственный контекст this
printText2('vity',)         // вызываем переменную как функцию передавая ей значения. порядок значений при вызове нельзя менять. значения которые могут не передаваться необходимо предусмотреть в конце при создании функции
printText3('Вася', 23)      // аргументы ('Вася', 23) это данные передаваемые непосредственно при вызове функции
// важно в каком порядке пишем параметры при создании функции, в таком же нужно передавать аргумменты при вызове функции
function operatorRest(name44, ...nam4) {             // оператор rest (...) говорит -> положи все значения передаваемых параметров в массив nam4
	console.log(name44, nam4)
}
operatorRest(333, 5, 1, 4, 7, 85, 5, 3)              // получим число 333 и затем запакованный массив из последующих элементов сколько бы их не было

function createPerson(name) {                        // Замыкания . это функция вложенная в функцию которая замыкается 
	return function (lastName) {
		console.log(name + ' ' + lastName)
	}
}
const addLastName = createPerson('Павел')
addLastName('иванов')
addLastName('сидоров')
addLastName('петров')

function Arg1Cons() {                                    // "arguments" Псевдомассив аргументов ( это не массив параметры не схожи с параметрами массива напимер отсутствуют методы массива) Функция может быть вызвана с произвольным количеством аргументов.
	console.log(!arguments.length)                        // (!arguments.length) если длинна аргументов имеется выдаст колличество. ставим оператор ! и передет в булевый вид и поменяет значение на противоположное
	if (!arguments.length) {                              // (!arguments.length) если длинна аргументов имеется выдаст колличество. ставим оператор ! и передет в булевый вид и поменяет значение на противоположное. если они не заданы то вернется folse но оператор ! поменяет значение на true и условие выполнется и в данном примере вернется return в функцию и она остановиться 
		console.log('аргументы не переданы')               //
		return                                             // if  вернет return в вункцию и она остановится если аргументов не будет 
	}
	for (let argument of arguments) {
		console.log(argument)
	}
	console.log('аргументов больше нет')
	console.log(arguments)                             // тут видим аргументы м массивовидном виде . у него как и у массива еть длинна и элементы начинаются с 0
}

Arg1Cons(798, 97, 86, 698, 7586, 65, 7)               // вызываем функцию 

let imya = 'Павел'
let vozrast = 56
printText('алкна', null)                          // пишем в аргументе null если не хотм передавать параметр  primerBezPar('даша', null, 25)
printText('миша', 34)
printText(imya, vozrast)                          // в функцию возможно передавать переменные
printText('даша', 22)
console.log(printText('NIKA', 55))                // пример возврата значения функции
let res3 = printText(imya, vozrast)               // значение функции возможно записать в переменную
console.log(res3)                                 // выводим значение перевенной с ранее присвоенной её функции
alert(res3)                                       // выводим значение перевенной с ранее присвоенной её функции

let obj33 = {
	name1: 'Иван',
	age2: 34,
	hello() {                                                 //если функция внутри объекта, то она называется методом данного объекта
		console.log(`мое имя ${this.name1} и мне ${this.age2} лет`)                     //this в даном случае обращаемся к элементам внутри объекта
	}
}
obj33.hello()                                                // вызываем метод внутри обекта, обращаемся к        обект.медод()

const arr22 = [1, 65, 5, 35, 54, 2, 23, 86, 4445, 45]           // функция с условиями внутри  другой функции sort(функция)
arr22.sort(function (a, b) {                                  // метод изменяет первоначальный массив ВНИМАНИЕ
	if (a > b) return 1;                                       // эти 3 строки можем заменить на  return  a-b
	if (a == b) return 0;
	if (a < b) return -1;
})
console.log(arr22)                                       // выводим массив



//-------------------------Документация кода JSDoc-------------------------------------- 
https://www.youtube.com/watch?v=0oHYhzb-dNQ&t=1240s
/**
 *   тут описание . напимер. функция преобразует строку с временем в минуты. в фигурных скобках указываем тип данных
 *  @param {string} time  (после фигурных скобок пишем название параметра) время в виде строки вмцукасу .  тут можно описать пример
 *  @return {number} Целое число в минутх. тут можно описать пример
 */
function timeToMinute(time) {
	try {
		let hour = +time.split(':')[0]
		let minute = +time.split(':')[1]
		if (!(hour >= 0 && hour <= 23) || !(minute >= 0 && minute <= 59)) {
			throw new RangeError('тут должен быть формат такой то и тако написан и прочее')              // throw генерирует ошибку 
		}
		return hour * 60 + minute
	} catch {
		//---------------------------console.log(error)     // тут не работает https://www.youtube.com/watch?v=jMoyWtoDtYA&t=610s
	}
}
console.log(timeToMinute('-02 : 43'))

//----------------------------ПОРТОТИПЫ------------------------------------------------
let admin = {                       // этот обект указали как портотип для объекта user
	rul: 7772,                        // это свойство наследуеется в объект  user
	isAdmin() {
		console.log('я админ ' + this.name + ' мои права' + this.rul)                   //  this.name  тут подставиться значение name из дочернего элемента.    но у  родителя нет доступа напрямую  к свойстваю дочернего объекта
	}    // методом называют обычную функцию внутри рбъекта. она так же наследуется 
}

let user = {
	name: 'Pavel',
	age: 23,
	__proto__: admin,                // так указываем портотип (родидель) объекта . __proto__ указывает на объект который является родительским у данного объекта
}

console.log(user.rul)               // тут обрашаемся к свойству которое добавлено через портатип объекта

//----------------------------КОНСТРУКТОР------------------------------------------------
function User11(name, age) {             // функции конструктор называют с заглавной буквы
	this.name = name;                     //  спомощью this создаем конструктор
	this.age = age;
	this.__proto__ = admin;                 // теперь каждый объеект создпнный этим конструктором будет наследоваться от admin это обязательно должен быть объект
	this.myInfo = function () {                         // чтобы создать метод в конструкторе нужно нужно писать следующее   this    не похоже на обычную фунуцию 
		console.log('меня зовут ' + this.name + ' мой возраст ' + this.age + ' лет')
	};
}

let u1 = new User11('сережа', 23)          // тут в новую переменную создаем объект с пофощью функции-конструктора new. 
console.log('конструктор ' + u1.rul)

let u2 = new User11('коля', 43)            // теперь с помощью конструктора возможно быстро создавать объекты
let u3 = new User11('галя', 21)           // теперь с помощью конструктора возможно быстро создавать объекты
console.log(u2)
console.log(u3.rul)                     // пример создания объекта и наследования через конструктор
console.log(u3.isAdmin())               // тут вызываем метод из родительского элемента и еще в этом методе есть ссылка на name которое подставляется уже из дочернего элемента
console.log(u3.isAdmin())               // тут вызываем метод из родительского элемента и еще в этом методе есть ссылка на name которое подставляется уже из дочернего элемента
console.log(admin)                      // тут мы не видим в портотипах дочерний элемент. соответсттвенно у родителя нет доступа к ним
u2.myInfo()                             // тут мызываем функцию (метод) созданную с помощью конструктора 

//---------------------------------------------------КЛАССЫ---------------------------------------------------------
// класс это фрагмент кода который позволяет легко создавать объекты

class User33 {                // с помощью ключевоо слова class создаем класс и присваиваем ему имя
	admin45 = 456                            // тут возможно указать самостоятельное свойство. при создании объекта оно попадет в него со значением в данном случае 456
	constructor(name, age, admin = false) {                // в скобках указываем параметры.   так же является специальным методом.    admin = false возможно использовать значения по умолчанию
		this.name = name;                    // в квадратных скобках методы(функции не пишем). тут только создаем параметры которые указали в круглых скобках
		this.age = age;                      // можно сказать все что записано в конструкторе в фигурные скобки, будет является телом сиздаваемого объекта.   можно сказать что методы ниже(вне вигурных скобок) с помощью портатипа наследуются
		this.admin = admin                   // если не укажкм значение , тогда будет использовано значение по умолчанию.это в данном примере.
	}
	myInfo33() {                                                                        // такой синтаксис метода (функция) у класса . просто указываем имя метода. можно сказать что методы с помощью портатипа наследуются
		console.log('меня зовут ' + this.name + ' мой возраст ' + this.age + ' лет')
		if (this.admin == true) {                                 // есть возможность указывать условия .нужно использовать this
			console.log('я админ')
		}
	};
}

let u11 = new User33('сережа', 23)           // вызвваем конструктор класса с помощью   new и создаем объекты с этими значениями
let u22 = new User33('коля', 43, true)
let u33 = new User33('галя', 21)

console.log(u33)                        // вызов созданного с комощью класса объекта
console.log(u22)                        // вывод измененного значения по умолчанию
console.log(u22.myInfo33())             // тут вызвали функцию и видим как работает условие в конструкторе

class Moderator55 extends User33 {                       // класс уноследуем от класса User33 c с помощью ключевого слова  extends   и соответственно он унаследует конструктор класса User33
	constructor(name, age, admin = false, moderat = true) {                          // тут мы переписали конструктор уноследовавшийся от User33
		super(name, age, admin = false)                                              // c помощью super(name, age, admin = false) переносим свойства из родительского. так же перечисляя параметры в круглых скобках
		this.moderat = moderat                                                       // так мы добавляем новое смойство в конструктор именно для Moderator55
	}
	static master22 = true                                                          // так же можно указывать и статические свойства класса
	addPost() {
		console.log('новый пост')
	}
	myInfo33() {
		super.myInfo33()                                     // с помощью слова super мы выведем метод от родителя и соответственно как в примере на следующей строке мы его дополняем командами .. т.е. выполнили сперва родительский метод и затем для Moderator55 дополнили его командами. в данном примере на следующей строке вывод в консоль
		console.log('такой же метод есть у родителя, но если мы его укажам тут то применется он. если нет тогда будет искать этот метод у родителя. ')            // если удалить тут данный метод. тогда применится метод с тем же именем от родителя
	}
	static test() {                            // static можно создавать статические методы. метод не доступен у объекта но дотупен у класса
		console.log('метод статик')
	}
}

let m1 = new Moderator55('Ivan', 54, true)                // унаследует конструктор класса User33 даже если мы не пишем его а указываем родителя с таким конструктором
console.log(m1)                                            // получается что у Moderator55 все те же свойства что и  у User33
m1.myInfo33()                                              // так же Moderator55 уноследовал и методы от User33,  если метод укажам в Moderator55 то примениться именно он. попробуйте удалить этот метод у Moderator55
Moderator55.test()                                        // метод  static доступен только у класса
//m1.test()                                                 // метод статик не доступин для создаваемого объекта. вызывает ошибку . поэтому закоментирован
console.log(Moderator55.master22)                         //свойство  static доступен только у класса 
console.log(m1.master22)                                  //свойство статик не доступин для создаваемого объекта.


//-----------------------------------------ПРАКТИКА--------------------------------------------------------



class People {                                                  // создаем класс для создания объектов.
	constructor(name, born, phoneNumber = '', address = '') {              // создали конструктор для People
		name = name.toLowerCase().split(" ");                     // тут мы переводим name в нижний регистр и далле делаем разделение с помощью split ПРИ ЭТОМ ПРИ ПРИМЕНЕНИИ split ВОЗВРАЩАЕТСЯ УЖЕ МАССИВ и ниже мы имеем в name массив и работаем с массивом	
		this.fullName = {};                                       // создаем пустой массив что бы мы могли записывать туда данные по отдельности (Ф И О) ниже. мы будем к нему обращаться и нужно что бы от был
		this.fullName.f = name[0][0].toUpperCase() + name[0].slice(1);           // в созданный выше объект уже записываем переменные . напоминаю что выше с помощью split мы имеем массив в name  и можем с ним работать как с массивом
		this.fullName.i = name[1][0].toUpperCase() + name[1].slice(1);           // берем поочередно каждый элемент массива .(шамлов[0] павел[1] сергеевич[2])   ,берем первый символ [0] (первую букву) и делаем заглавной 
		this.fullName.o = name[2][0].toUpperCase() + name[2].slice(1);           // прибавляем к каждому элементу массива тот же массив со второго символа и до конца с помощью slice
		born = born.split(".");                                   // с помощью split перавращаем строку даты в массив даты разделителем в данном случае служит точка
		this.born = {};                                            // создаем пустой объект с помощью this (т.е. пустой объект так же будет создаваться в создаваемом нами объекте с помощью конструктора) куда будем помещать дату месяц и год в виде массива
		this.born.d = +born[0];                                      // в созданный выше объект born уже записываем переменные . напоминаю что выше с помощью split мы имеем массив в name  и можем с ним работать как с массивом
		this.born.m = +born[1];                                      // с помощью + делаем конвертацию из типа строка в тип число
		this.born.g = +born[2];
		phoneNumber = phoneNumber.split(', ')                       // разделим номера т.е. с помощью split  превратим строку в массив и разделителем будет служить ("запятая пробел")
		this.telefon = []                                           // c помощью this создадим пустой массив т.к. номера телефонов удобнее хранить в массиве
		for (let i = 0; i < phoneNumber.length; i++) {              // проходим циклом по массиву
			this.telefon.push(phoneNumber[i])                        // записываем каждый номер в массив telefon
		}
		this.adres = +address;                                   // с помощью this продолжаем создавать объект . наше имя в объекте = (имя в конструкторе (имена обычно совпадают)) 
	}
	static monthList = ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря']

	getFio() {
		return `моя фамилия ${this.fullName.f} имя ${this.fullName.i} отчество ${this.fullName.o}`         // создали метод вывода ФИО . тут возвращаем значение сразу в функцию
	}
	getBirthday() {
		return `${this.born.d} ${People.monthList[this.born.m - 1]} ${this.born.g}`
	}
	getImgSrc(format) {
		return `${this.fullName.f}_${this.fullName.i}_${this.fullName.o}.${format}`                        // добавляем к функции аргумент и выводим с инм тоже в фигурных скобках ${format}
	}
	getTelefon(allNumbers) {                                            // договоримся если аргумент true все номера телевонов если fulse тогда первый номер
		if (!!this.telefon.length == 0 || !!this.telefon[0].length == 0) {        // с помощью оператора или проверим нет ли в номере релефона пустой строки или его длинна равна 0 . подстрахуемся в условии !! чтобы были булевые значения
			return 'вы не ввели номер телефона'
		}
		if (allNumbers == true) {                                        // вводим условие если истино то выполняем код ниже
			return this.telefon.join(', ')                                // join(', ') превращает  в строку с разделением запятая пробел
		} else {
			return this.telefon[0]
		}

	}
}

let people1 = new People('Шамлов Павел Сергеевич', '08.11.1986', '8926542848, 89258643838', 6666)       // с помощью каласса создаем массив с менем  people1
let people2 = new People('иваНов пеТР КОнСтАнтинович', '12.2.1934', '89262342345, 8925834523', 235)
console.log(people1)
console.log(people1.getFio())                                                                            // вызов метода у создаваемого через класс обекта и самого метода
console.log(people2.getBirthday())                                                                            // вызов метода у создаваемого через класс обекта и самого метода
console.log(people1.getImgSrc('png'))                                                                            // вызов метода у создаваемого через класс обекта и самого метода
console.log(people1.getTelefon(true))                                                                            // вызов метода у создаваемого через класс обекта и самого метода



//----------------------------------------ДОПОЛГИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ES6 ----------------------------------------
function sum54(a, b) {
	return a + b
}
let date = [4, 8]                           // массив
console.log(sum54(...date))   // ... три точки, оператор расширения. если массив необходимо быстро передать в функцию. благодаря оператору расширения этот массив разбился на одиночные значения и подставились в параметры функции

let [a, b, c, d] = [32, 'привет', false, 745]  // дистуктивное присваивание. например создать 4 переменные и присвоить им значения из другого массива
console.log(b)

let arr334 = [43, 324, 234, 'sdfvb', 213, true, 432]               // произвольный массив
console.log(arr334.fill(0, 1, 5))                                        // заполняет массив однотипными данными которые укажем . можно указать ио и до

let arr335 = [43, 324, 234, 'sdfvb', 213, true, 432]               // произвольный массив
console.log(...(arr335.entries()))                      // возвращает индекс массва  и значение массива и все это в отдельном массиве
console.log(...(arr335.keys()))                         // возвращает индекс массива
console.log(...(arr335.values()))                       // возвращает значения массива

Number.isInteger(18) // появилась функция проверки на целое  число        true
Number.isInteger(18.0) // появилась функция проверки на целое  число      true
Number.isInteger(18.3) // появилась функция проверки на целое  число      false
console.log(Number.isInteger(18.0))  //пример  возвращает булевое значение 
Number.isNaN()// работа с NaN в ES6 применяем банную функцию, она возвращает true если значение Nan и false в обратном случае. никакие дополнительные проверки как ES5 не требуются.   в скобках проверяемый параметр

console.log(Math.sign(-54))  // метод позволяющий определить знак числа . -1 число отрицательное . 0  число ноль   1 -  число положительное

let set45 = new Set()                         // позволяет хранить уникальные значения любого типа
set45.add(2)
set45.add(4)
set45.add(6)                        // добавляем элемент в множество
set45.add(2)
set45.add(1)                        // повторяющийся элемент не добавляется в множество
console.log(set45)
console.log(set45.has(6))           // проверка имеется ли какое либо значение в множестве. возвращает булевое значение
console.log(set45.size)             // размер множества 
set45.delete(4)                     // удаляем элемент из множества
console.log(set45)
set45.clear()                       // очищает множество от всех элементов
console.log(set45)





//------------------------РАБОТА С DOM--------------------------------------------------------------
// классы и стили
элемент.className = 'название класса'  // позволяет ПОЛНОСТЬЮ переписать, класс у элемента класс в кавычках , элемент можно получить с помощью document.querySelector('div') . все элементы класса получаем как одну строку
элемент.classList    // это псевдомассив c классами и с ним можно работать циклом for of.
for (let classElem33 of элемент.classList) {       //ишим не в элементе а в ( элемент.classLis ) ведь элемент это еще не псевдомассив а ( элемент.classLis ) это уже псевдомассив
	console.log(classElem33)                        // получим имя каждого класса отдельно при каждй итерации
}
элемент.classList.contains("название класса")             // возвращает true / false, в зависимости от того, есть ли у элемента класс 'название класса'.
элемент.classList.add / remove("название класса")         // добавляет / удаляет класс 'название класса'. если приудалении remove   удаляемый класс не находит то это не вызывает ошибку
элемент.classList.toggle("название класса")               // если класса 'название класса' нет, добавляет его, если есть – удаляет.
элемент.style.color = 'red'                       // добавляет стили style в HTML разметку имеет больший приоритет . записываем css свойства после точки  если css свойство через дифис background-color  его пишем сamelCase    backgroundСolor
элемент.style.display = 'none'   -- > элемент.style.display = ''     // если скрыли элемент , то вернуть первоначальное положение можно присвоить пустыми кавычками напримкер был flex и станет тотже flex
getComputedStyle(элемент)                // только для чтения  получим окончательный список свойств и значений в css (с учетом всех приоритетов и переопределений) включая те которые записали в html c помощью атрибута елемент.style  
getComputedStyle(элемент, [pseudo])      // только для чтения pseudo  Указывается, если нужен стиль псевдоэлемента, например ::before. Пустая строка или отсутствие аргумента означают сам элемент.
getComputedStyle(элемент).color          // так получим значение конкретного свойства . в данном случае color..    не видит стили, применяемые с помощью :visited
// метрики положение элемента
элемент.




