






















//-----------ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ--------------------------------------------------------------------------------------


//==================================================================================================================


























//-----------деструктуризация объектов--------------------------------------------------------------------------------------
//деструктуризация  это получение значений или имен обекта в переменную но с коротким и удобным синтаксисом
// (закоментировано т.к. ниже пример с такимиже именами констант)const { name, age, lang } = person         // тут получаем 3 констаны из объекта person со значениями. имена констант соответственно совпадают с ключами. если такие нонстанты уже есть тогда будет ошибка и необходимо применять иной способ
const { name: firstName, age = 45, lang } = person      //   тут положи в КОНСТАНТУ firstName значение из person и имени name. соответственно можем создавать константы уже с любыми именами. если значение не задано (отсутствует или =undefined)в объекте то возможно задать по умолчанию напримет возраст 
console.log(firstName, age, lang)               // проверяем созданные константы в консоли 

for (let key in person) {                      // итерации по ключам и значениям объекта. создаем переменную key и в нее помещаем имена из обекта person 
	if (person.hasOwnProperty(key)) {           // тут добавляем (hasOwnProperty) проверку для получения только собственных ключей и соответственно значений, т.к. обычный цикл идет и по портотипам 
		console.log(key)                         // тут видим имена(ключи)
		console.log(person[key])                 // тут подставляя ключи получаем значения из объекта
	}
}

const keys123 = Object.keys(person)            // метод получения ключей(имен) объекта в виде массива с помощью Object.keys (не затрагивает цепочку портатипов объекта)
console.log(keys123)                           // ключи объекта в массиве

keys123.forEach((key) => {                      // Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.
	console.log(person[key])                    // получаем значения для каждого элемента (ключа) объекта
})

Object.keys(person).forEach((key) => {         // тут мы сократили лишнюю переиенную и keys123  и записали напрямую. т.к. она просто взвращает массив имен. даллеперебрали с помощью метода forEach()
	console.log(person[key])
})
// работа с this с помощью метода bind() мы получим доступ к любому массиву и будем работать с функциями из массива logger1
const logger1 = {
	keys1() {
		console.log('ключи объекта', Object.keys(this))      // Object.keys     с заглавной буквы     получаем массив имен объекта
	},

	klychiIZnacheniya() {
		Object.keys(this).forEach((key) => {
			console.log('klych ', key)                         //получаем ключи
			console.log('znachenie ', this[key])               // получаем значение 
		})

	}
}

const test1 = logger1.keys1.bind(person)          //   метод bind() проверяем в консоли    
test1()                                           // тут в скобки можно передавать параметр в данном случае keys1(вот сюда упадет параметр)
const test2 = logger1.klychiIZnacheniya.bind(person)          // проверяем в консоли
test2()
logger1.klychiIZnacheniya.bind(person)()          //  такая запись тоже самое что и выше но встречается чаще .т.е. в строке сразу вызываем функцию    проверяем в консоли 

const test3 = logger1.keys1.call(person)          //  метод call()   отличия от bind() в том что он сразу вызывается. не нужно добавлять скобки в конце(вызывать)          проверяем в консоли
logger1.keys1.call(person)                        // logger1.keys1.call(person, параметр1, параметр, ....) вариант записи без переменной (тут параметры будут из обекта keys1(вот сюда встает этот параметр))
logger1.keys1.apply(person)                      // logger1.keys1.apply(person, [пар1, пар2, ...])   тоже самое что и call но параметры является массив












//-------------------------Документация кода JSDoc-------------------------------------- 
https://www.youtube.com/watch?v=0oHYhzb-dNQ&t=1240s
/**
 *   тут описание . напимер. функция преобразует строку с временем в минуты. в фигурных скобках указываем тип данных
 *  @param {string} time  (после фигурных скобок пишем название параметра) время в виде строки вмцукасу .  тут можно описать пример
 *  @return {number} Целое число в минутх. тут можно описать пример
 */
function timeToMinute(time) {
	try {
		let hour = +time.split(':')[0]
		let minute = +time.split(':')[1]
		if (!(hour >= 0 && hour <= 23) || !(minute >= 0 && minute <= 59)) {
			throw new RangeError('тут должен быть формат такой то и тако написан и прочее')              // throw генерирует ошибку 
		}
		return hour * 60 + minute
	} catch {
		//---------------------------console.log(error)     // тут не работает https://www.youtube.com/watch?v=jMoyWtoDtYA&t=610s
	}
}
console.log(timeToMinute('-02 : 43'))


























//----------------------------КОНСТРУКТОР------------------------------------------------
function User11(name, age) {             // функции конструктор называют с заглавной буквы
	this.name = name;                     //  спомощью this создаем конструктор
	this.age = age;
	this.__proto__ = admin;                 // теперь каждый объеект создпнный этим конструктором будет наследоваться от admin это обязательно должен быть объект
	this.myInfo = function () {                         // чтобы создать метод в конструкторе нужно нужно писать следующее   this    не похоже на обычную фунуцию 
		console.log('меня зовут ' + this.name + ' мой возраст ' + this.age + ' лет')
	};
}

let u1 = new User11('сережа', 23)          // тут в новую переменную создаем объект с пофощью функции-конструктора new. 
console.log('конструктор ' + u1.rul)

let u2 = new User11('коля', 43)            // теперь с помощью конструктора возможно быстро создавать объекты
let u3 = new User11('галя', 21)           // теперь с помощью конструктора возможно быстро создавать объекты
console.log(u2)
console.log(u3.rul)                     // пример создания объекта и наследования через конструктор
console.log(u3.isAdmin())               // тут вызываем метод из родительского элемента и еще в этом методе есть ссылка на name которое подставляется уже из дочернего элемента
console.log(u3.isAdmin())               // тут вызываем метод из родительского элемента и еще в этом методе есть ссылка на name которое подставляется уже из дочернего элемента
console.log(admin)                      // тут мы не видим в портотипах дочерний элемент. соответсттвенно у родителя нет доступа к ним
u2.myInfo()                             // тут мызываем функцию (метод) созданную с помощью конструктора 


































//-----------------------------------------ПРАКТИКА--------------------------------------------------------






class People {                                                  // создаем класс для создания объектов.
	constructor(name, born, phoneNumber = '', address = '') {              // создали конструктор для People
		name = name.toLowerCase().split(" ");                     // тут мы переводим name в нижний регистр и далле делаем разделение с помощью split ПРИ ЭТОМ ПРИ ПРИМЕНЕНИИ split ВОЗВРАЩАЕТСЯ УЖЕ МАССИВ и ниже мы имеем в name массив и работаем с массивом	
		this.fullName = {};                                       // создаем пустой массив что бы мы могли записывать туда данные по отдельности (Ф И О) ниже. мы будем к нему обращаться и нужно что бы от был
		this.fullName.f = name[0][0].toUpperCase() + name[0].slice(1);           // в созданный выше объект уже записываем переменные . напоминаю что выше с помощью split мы имеем массив в name  и можем с ним работать как с массивом
		this.fullName.i = name[1][0].toUpperCase() + name[1].slice(1);           // берем поочередно каждый элемент массива .(шамлов[0] павел[1] сергеевич[2])   ,берем первый символ [0] (первую букву) и делаем заглавной 
		this.fullName.o = name[2][0].toUpperCase() + name[2].slice(1);           // прибавляем к каждому элементу массива тот же массив со второго символа и до конца с помощью slice
		born = born.split(".");                                   // с помощью split перавращаем строку даты в массив даты разделителем в данном случае служит точка
		this.born = {};                                            // создаем пустой объект с помощью this (т.е. пустой объект так же будет создаваться в создаваемом нами объекте с помощью конструктора) куда будем помещать дату месяц и год в виде массива
		this.born.d = +born[0];                                      // в созданный выше объект born уже записываем переменные . напоминаю что выше с помощью split мы имеем массив в name  и можем с ним работать как с массивом
		this.born.m = +born[1];                                      // с помощью + делаем конвертацию из типа строка в тип число
		this.born.g = +born[2];
		phoneNumber = phoneNumber.split(', ')                       // разделим номера т.е. с помощью split  превратим строку в массив и разделителем будет служить ("запятая пробел")
		this.telefon = []                                           // c помощью this создадим пустой массив т.к. номера телефонов удобнее хранить в массиве
		for (let i = 0; i < phoneNumber.length; i++) {              // проходим циклом по массиву
			this.telefon.push(phoneNumber[i])                        // записываем каждый номер в массив telefon
		}
		this.adres = +address;                                   // с помощью this продолжаем создавать объект . наше имя в объекте = (имя в конструкторе (имена обычно совпадают)) 
	}
	static monthList = ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря']

	getFio() {
		return `моя фамилия ${this.fullName.f} имя ${this.fullName.i} отчество ${this.fullName.o}`         // создали метод вывода ФИО . тут возвращаем значение сразу в функцию
	}
	getBirthday() {
		return `${this.born.d} ${People.monthList[this.born.m - 1]} ${this.born.g}`
	}
	getImgSrc(format) {
		return `${this.fullName.f}_${this.fullName.i}_${this.fullName.o}.${format}`                        // добавляем к функции аргумент и выводим с инм тоже в фигурных скобках ${format}
	}
	getTelefon(allNumbers) {                                            // договоримся если аргумент true все номера телевонов если fulse тогда первый номер
		if (!!this.telefon.length == 0 || !!this.telefon[0].length == 0) {        // с помощью оператора или проверим нет ли в номере релефона пустой строки или его длинна равна 0 . подстрахуемся в условии !! чтобы были булевые значения
			return 'вы не ввели номер телефона'
		}
		if (allNumbers == true) {                                        // вводим условие если истино то выполняем код ниже
			return this.telefon.join(', ')                                // join(', ') превращает  в строку с разделением запятая пробел
		} else {
			return this.telefon[0]
		}

	}
}

let people1 = new People('Шамлов Павел Сергеевич', '08.11.1986', '8926542848, 89258643838', 6666)       // с помощью каласса создаем массив с менем  people1
let people2 = new People('иваНов пеТР КОнСтАнтинович', '12.2.1934', '89262342345, 8925834523', 235)
console.log(people1)
console.log(people1.getFio())                                                                            // вызов метода у создаваемого через класс обекта и самого метода
console.log(people2.getBirthday())                                                                            // вызов метода у создаваемого через класс обекта и самого метода
console.log(people1.getImgSrc('png'))                                                                            // вызов метода у создаваемого через класс обекта и самого метода
console.log(people1.getTelefon(true))                                                                            // вызов метода у создаваемого через класс обекта и самого метода



//----------------------------------------ДОПОЛГИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ES6 ----------------------------------------
function sum54(a, b) {
	return a + b
}
let date = [4, 8]                           // массив
console.log(sum54(...date))   // ... три точки, оператор расширения. если массив необходимо быстро передать в функцию. благодаря оператору расширения этот массив разбился на одиночные значения и подставились в параметры функции

let [a, b, c, d] = [32, 'привет', false, 745]  // дистуктивное присваивание. например создать 4 переменные и присвоить им значения из другого массива
console.log(b)

let arr334 = [43, 324, 234, 'sdfvb', 213, true, 432]               // произвольный массив
console.log(arr334.fill(0, 1, 5))                                        // заполняет массив однотипными данными которые укажем . можно указать ио и до

let arr335 = [43, 324, 234, 'sdfvb', 213, true, 432]               // произвольный массив
console.log(...(arr335.entries()))                      // возвращает индекс массва  и значение массива и все это в отдельном массиве
console.log(...(arr335.keys()))                         // возвращает индекс массива
console.log(...(arr335.values()))                       // возвращает значения массива

Number.isInteger(18) // появилась функция проверки на целое  число        true
Number.isInteger(18.0) // появилась функция проверки на целое  число      true
Number.isInteger(18.3) // появилась функция проверки на целое  число      false
console.log(Number.isInteger(18.0))  //пример  возвращает булевое значение 
Number.isNaN()// работа с NaN в ES6 применяем банную функцию, она возвращает true если значение Nan и false в обратном случае. никакие дополнительные проверки как ES5 не требуются.   в скобках проверяемый параметр

console.log(Math.sign(-54))  // метод позволяющий определить знак числа . -1 число отрицательное . 0  число ноль   1 -  число положительное

let set45 = new Set()                         // позволяет хранить уникальные значения любого типа
set45.add(2)
set45.add(4)
set45.add(6)                        // добавляем элемент в множество
set45.add(2)
set45.add(1)                        // повторяющийся элемент не добавляется в множество
console.log(set45)
console.log(set45.has(6))           // проверка имеется ли какое либо значение в множестве. возвращает булевое значение
console.log(set45.size)             // размер множества 
set45.delete(4)                     // удаляем элемент из множества
console.log(set45)
set45.clear()                       // очищает множество от всех элементов
console.log(set45)





//------------------------РАБОТА С DOM--------------------------------------------------------------
// классы и стили
элемент.className = 'название класса'  // позволяет ПОЛНОСТЬЮ переписать, класс у элемента класс в кавычках , элемент можно получить с помощью document.querySelector('div') . все элементы класса получаем как одну строку
элемент.classList    // это псевдомассив c классами и с ним можно работать циклом for of.
for (let classElem33 of элемент.classList) {       //ишим не в элементе а в ( элемент.classLis ) ведь элемент это еще не псевдомассив а ( элемент.classLis ) это уже псевдомассив
	console.log(classElem33)                        // получим имя каждого класса отдельно при каждй итерации
}
элемент.classList.contains("название класса")             // возвращает true / false, в зависимости от того, есть ли у элемента класс 'название класса'.
элемент.classList.add / remove("название класса")         // добавляет / удаляет класс 'название класса'. если приудалении remove   удаляемый класс не находит то это не вызывает ошибку
элемент.classList.toggle("название класса")               // если класса 'название класса' нет, добавляет его, если есть – удаляет.
элемент.style.color = 'red'                       // добавляет стили style в HTML разметку имеет больший приоритет . записываем css свойства после точки  если css свойство через дифис background-color  его пишем сamelCase    backgroundСolor
элемент.style.display = 'none'   -- > элемент.style.display = ''     // если скрыли элемент , то вернуть первоначальное положение можно присвоить пустыми кавычками напримкер был flex и станет тотже flex
getComputedStyle(элемент)                // только для чтения  получим окончательный список свойств и значений в css (с учетом всех приоритетов и переопределений) включая те которые записали в html c помощью атрибута елемент.style  
getComputedStyle(элемент, [pseudo])      // только для чтения pseudo  Указывается, если нужен стиль псевдоэлемента, например ::before. Пустая строка или отсутствие аргумента означают сам элемент.
getComputedStyle(элемент).color          // так получим значение конкретного свойства . в данном случае color..    не видит стили, применяемые с помощью :visited
// метрики положение элемента
элемент.




