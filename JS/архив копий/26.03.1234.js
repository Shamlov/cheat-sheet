'use strict'

//----ФУНКЦИИ---блок кода которые можно выполнять многократно------это объект-----------------------------------------------------------
// в (a, b) записываем параметры функции. можно сказать, что параметры  a, b медут себя будто переменные в теле функции. их значения определяются в момент вызова функции.
let conclusion2 = 34                                          // доступ к переменной объявленной за пределами функции возможен из любого места          
function printText(name2, age2) {                             // Function Declaration Объявление функции. можем вызывать функцию выше по коду (вызов из любого места кода)(функции в таком виде "Всплывают")  (name2, age2) называют параметры функции , а когда вызываем функцию эти данные называются аргументы
	let conclusion1                                           // внутри функции возможно объявит переменную. за пределами функции переменную не видно
    conclusion1 = `меня зовут ${name2} мой возраст ${age2}`   // при создании функции продумывать какие параметры будут обязательны (вначале пишем их) а какие  опциональные. это нужон если параметр не передадут (обязатель, обязательный, опция можно не передавать)
    console.log(conclusion1)                                      
    console.log(conclusion2)                                  // внутри функции возможен доступ к переменной объявленной за пределами функции.                                  
    conclusion2 = 'изменение значения переменной'
	return `мое имя ${name2} мне ${age2} лет`                 // тут мы возвращаем значение в функцию. в данном примере printText
}
printText('Вася', 45)                 // вызываем функцию с параметрами. Вася строка плэтому в кавычках ''. Порядок значений при вызове нельзя менять. Значения которые могут не передаваться необходимо предусмотреть в конце при создании функции.
console.log(printText('Дима', 11))    // тут видим что функция возвращает return  другое предложение и так же выполняет console.log внутри себя.
console.log(conclusion1)              // доступ к объявленной внутри функции переменной невозможен снаружи(ошибка).
console.log(conclusion2)              // доступ к объявленной переменной за пределами функции возможен как внутри так и снаружи функции

let imya = 'Павел'                                 // в функцию возможно передавать переменные
let vozrast = 56                                   // в функцию возможно передавать переменные
const printText2 = function (name2 = 'антон', age2 = 45) {        // function expression сразу присваиваем анонимную функцию переменной(const или let). функцию нельзя вызывать до ее объявления. не всплывает. можем передавать значения по умолчанию. 
    let sam = age2 * 2            
	console.log(`меня зовут ${name2} мой возраст ${age2 * 3}`)    // в параметры по умолчанию мозможно вычислять (age = 18, sam = age*2)
	return `меня зовут ${name2} мой возраст ${age2}`              // return слово которое останавливает выполнение функции (ниже код не выполняется) и записывает это значение в имя функции. здесь мы возвращаем значение в функцию.
    console.log(sam)                                              // после return код не выполняется поэтому не выдим вывода в консоль 
}
console.log(printText2('Коля'))  // меня зовут Коля мой возраст 135   // меня зовут Коля мой возраст 45
printText2(imya, vozrast)        // меня зовут Павел мой возраст 168  // в функцию возможно передавать переменные
printText2(null, 43)       // ВОпрос передача null // пишем в аргументе null если не хотм передавать параметр  primerBezPar('даша', null, 25)

const printText3 = (name2 = 'антон', age2 = 45) => console.log(`меня зовут ${name2} мой возраст ${age2}`)        // arrow function стрелочная функция. если 1 действие пишем в строку без{} return не пишем. return не явный (ставиться по умолчанию). если несколько действий в функции тогда ставим {} пищем как и в обычной функции каждое действие с новой строки и вконце обязательно пишем return если требуется. нет параметра "arguments" . не создают свой собственный контекст this

function operatorRest(name44, ...nam4) {   // оператор rest (...) говорит -> положи все значения передаваемых параметров в массив nam4
	console.log(name44, nam4)
}
operatorRest(333, 5, 1, 4, 7, 85, 5, 3)    // 333 [ 5, 1, 4, 7, 85, 5, 3] // получим число 333. И запакованный массив из последующих элементов, сколько бы их не было

let obj33 = {                                                           // метод использующий в качестве аргумента значения объекта в котором находиться.
	name1: 'Иван',
	age2: 34,
	hello() {                                                           // если функция внутри объекта, то она называется методом данного объекта.
		console.log(`мое имя ${this.name1} и мне ${this.age2} лет`)     // this в даном случае обращаемся к элементам внутри объекта.
	}
}
obj33.hello()  

const person1 = {                // мутирование обекта с помощью функции. не рекомендуется так делать
    myName: 'Pavel',
    age: 25,                    
}
function myData(myAge) {
    myAge.age = myAge.age + 100  // т.к. передается в аргумент ссылка на объект, мы мутируем этот объект. не рекомендуют мутировать объект в функции
    return myAge                 // если ничего не хотим возвращать, тогда не пишем. функчия и без этого внесет данные в объект.
}
myData(person1)       // в функцию передаем объект по ссылке. функция изменит данные и присвоет новое значение в передаваемом объекте.
console.log(person1)  // { myName: 'Pavel', age: 125 }.   получается мутировали объект

const person1 = {                // работа с копией объекта созданного внутри функции функции.
    myName: 'Pavel',
    age: 25,                    
}
function myData(myAge) {
    const copyPerson1 = Object.assign({}, myAge)
    copyPerson1.age = copyPerson1.age + 100    // работаем с копией передаваемого в функцию объекта.
    return copyPerson1                // если ничего не хотим возвращать, тогда не пишем. функция и без этого внесет данные в объект.
}
console.log((myData(person1)))  // { myName: 'Pavel', age: 125 } // в функцию передаем объект по ссылке. функция сделает копию обекта и изменит данные в копии.
console.log(person1)            // { myName: 'Pavel', age: 25 }.   передаваемый объект не мутировал.

function printMyName() {         // это колбек функция. в функцию setTimeout передаем в качестве аргумерта другую функцию. в этом и весь смысл.
    console.log(`Pavel`)         // вопрос. setTimeout(printMyName(как сюда передать значение??), 1000).
}                             
setTimeout(printMyName, 1000)    // когда передаем в качестве аргумента другую функцию () не ставим, т.е. она вызовется автоматически.




// function createPerson(name) {                        // Замыкания . это функция вложенная в функцию которая замыкается 
// 	return function (lastName) {
// 		console.log(name + ' ' + lastName)
// 	}
// }
// const addLastName = createPerson('Павел')
// addLastName('иванов')
// addLastName('сидоров')
// addLastName('петров')



// function Arg1Cons() {                                  // "arguments" Псевдомассив аргументов ( это не массив параметры не схожи с параметрами массива напимер отсутствуют методы массива) Функция может быть вызвана с произвольным количеством аргументов.
// 	console.log(!arguments.length)                        // (!arguments.length) если длинна аргументов имеется выдаст колличество. ставим оператор ! и передет в булевый вид и поменяет значение на противоположное
// 	if (!arguments.length) {                              // (!arguments.length) если длинна аргументов имеется выдаст колличество. ставим оператор ! и передет в булевый вид и поменяет значение на противоположное. если они не заданы то вернется folse но оператор ! поменяет значение на true и условие выполнется и в данном примере вернется return в функцию и она остановиться 
// 		console.log('аргументы не переданы')              
// 		return                                            // if  вернет return в вункцию и она остановится если аргументов не будет 
// 	}
// 	for (let argument of arguments) {
// 		console.log(argument)
// 	}
// 	console.log('аргументов больше нет')
// 	console.log(arguments)                             // тут видим аргументы м массивовидном виде . у него как и у массива еть длинна и элементы начинаются с 0
// }







// const arr22 = [1, 65, 5, 35, 54, 2, 23, 86, 4445, 45]           // функция с условиями внутри  другой функции sort(функция)
// arr22.sort(function (a, b) {                                    // метод изменяет первоначальный массив ВНИМАНИЕ
// 	if (a > b) return 1;                                           // эти 3 строки можем заменить на  return  a-b
// 	if (a == b) return 0;
// 	if (a < b) return -1;
// })
// console.log(arr22)         




