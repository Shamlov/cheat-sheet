https://www.responsivebreakpoints.com/    Генератор отзывчивых (responsive) тегов и картинок
https://www.flaticon.com/                 Иконки
https://placekitten.com/                  Сайт с котиками
https://placehold.co/                     Шаблонные (плейсхолдер) картинки
https://inkscape.org/                     Векторный редактор
https://caniuse.com/                      Проверка поддержки свойств
https://www.fontconverter.io/en           конвертируем шрифт    в css шрифта пишем адекватное название задаем font-style: ; font-weight: 

Alt+Z            Переключить перенос текста
Ctrl + /         Закомментировать код
Shift + Alt + F  Pritter
Alt              Множественный ввод
проб + Ctrl      Подсказка
Ctrl + d         Обернуть в тег
Ctrl + h         найти и заменить
Ctrl + Alt + T   перевод


[header nav] [main section] aside footer
div – элементы с таким тегом.                  <div></div> выберет все div
#id – элемент с данным id.                     <div id="languages"></div>
.class – элементы с таким классом.             <div class="languages"></div>
[name="value"] – селекторы на атрибут          В правилах важен регистр букв (строчные/заглавные) 
            [attr] – атрибут установлен,
            [attr="val"] – атрибут равен val.      <input type="checkbox">      input[type="checkbox"]
            [attr^="val"] – атрибут начинается с val, например "value".
            [attr$="lue"] - атрибут заканчивается на lue, например "value"   удобно проверять расшитения 
            [attr|="val"] – атрибут равен val или начинается с val- (дифис), например равен "val-1"
            [attr*="val"] – атрибут содержит подстроку (в слове) val, например равен "myvalue".
            [attr~="val"] – атрибут содержит val как одно из значений через пробел.
:visited – «псевдоклассы», остальные разные условия на элемент 
.c1.c2 – элементы одновременно с двумя классами c1 и c2  (запись без пробела)
p.class - элемент одновременно с <p> и .class как выше только можно группировать так и id теги классы *  без пробела
a#id.c1.c2:visited – элемент a с данным id, классами c1 и c2, и псевдоклассом visited
div p – элементы p, являющиеся потомками div
div > p – только непосредственные потомки (первый уровень детей)
div ~ p – правые соседи: все p на том же уровне вложенности (не родитель и ребенок) !!!, которые идут после div.   (выбирает всех братьев и сестер, справа от div можно не соседей)
div + p – выберет всех правый соседей: p на том же уровне вложенности( не родитель и ребенок)!!!, который идёт сразу после div (если есть).выбирает которые идут друг за другом . (прием li+li выберет li кроме первого ) 

:first-child – первый потомок своего родителя.       .class li:last-child  запись равим образом . т.е. первый li в списке c .class   если li не указать, то просто выберет первый элемент в указанном классе . если нет первого li, то не выберет ничего. 
:last-child – последний потомок своего родителя.     .class li:last-child  запись равим образом . т.е. последний li в списке c .class 
:only-child – единственный потомок своего родителя, соседних элементов нет.
:nth-child(a) – потомок номер a своего родителя, например :nth-child(2) – второй потомок. Нумерация начинается с 1.
:nth-child(an+b) – расширение предыдущего селектора через указание номера потомка формулой, где a,b – константы, а под n подразумевается любое целое число.   например 3n применится к каждому 3-му элементу , а   +1  с какого элемента стартуем (с 1-ого). отсчет начинается не с первого а от первого (3n+1 выберет 1-й 4-й и тд)
:nth-last-child(a), :nth-last-child(an+b) – то же самое, но отсчёт начинается с конца, например :nth-last-child(2) – второй элемент с конца.
:first-of-type  :last-of-type  :only-of-type  :nth-of-type  :nth-last-of-type  на этом же уровне вложенности по типу селектора(тега или класса и пр.). Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:                    li:first-of-type  выберет первый li даже если перед ним другие теги
:not(селектор) – все, кроме подходящих под селектор.         <input type="checkbox" checked>    input[type="checkbox"]:not([checked])  не выберет его   .  li:not(:last-child):not(.active) можнописать составные (выберет все кроме последнего и кроме .active) . нельзя вкладывать :not(:not)
:focus – в фокусе.
:hover – под мышью.
:empty – без детей (даже без текстовых).
:checked, :disabled, :enabled – состояния INPUT.
:target – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.

больший приоритет у элемента нежели у родителя. стили в html самый высокий приоритет <p style =" "></p>
:is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок.
Селектор	                        Вес      калькулятор специфичности https://polypane.app/css-specificity-calculator/#selector=      https://specificity.keegan.st/        https://www.codecaptain.io/tools/css-specificity-calculator
#some	(id)                       1.0.0     селектор по ID
.class или (attr, pseudo-class)    0.1.0     класс, атрибут,псевдокласс      нарастить класс (.tomato) им самим же. Класс можно продолжать наращивать, пока вам не хватит специфичности (.tomato.tomato.tomato)
<span>   (elem, pseudo-elem)       0.0.1     тег или псевдоэлемент
+  >  ~  *  :where()               0.0.0     +, >, ~, универсальный селектор * и псевдокласс :where() веса не имеют.

counter-reset: step 0    counter-increment: step 1 ;      counter(step)                content: counter(step) "."     тут выводим переменную в псевлоэлемент в кавычках можем добавить дополнительный тектс

element::before {
    content: "";
    display: block;
    height: 30px;
    background-image: url("");
    background-size: contain;                 
    background-repeat: no-repeat;
    background-position: center;   }z

Блок__элем_модиф  блок используем многократно, не задаем внешних отступов. элемент неотемлемая часть текущего блока. элементу возможно задавать через дефис имена родители и затем свое имя. блоки вкладываются в другие блоки и добавляется класс.  модификатор можно добавить и блоку и элементу. у модификатора возможно добавить еще параметры. 

родитель img{                                                        img{
    position: relative;                                                 width: 100%;   
    overflow: hidden;                                                   height: 100%;        
    padding-top: 40%; падинг на на месте картинки                       object-fit: cover;         
}                                                                       position: absolute;
                                                                        top: 0;
                                                                        left: 0;  }

position: relative  top, right, bottom, left  z-index  не выпадает из потока
absolute;  top, right, bottom, left  z-index            выпадает из потока. уменьшается под контент.  родителю position: relative   или absolute или fixed и он позичионируется относительно него. margin абсолютно позиционированных блоков не схлопываются. 
fixed    выпадает из потока. уменьшается под контент. позиционирование отпосительно окна браузера. фиксирует на странице(не скролица).
sticky сперва как обычно. при скроле прилепает к верхней границы окна браузера
absolute или fixed можно натянуть на родитель указав задав одновременно противоположные свойства (left и right, или top и bottom) (inset). будет работать, если width и height будут иметь значение auto
приоритет отдаётся свойству left и top

flex-direction: – главная ось, значения: row  column  row-reverse  column-reverse.
flex-wrap: -  перенос строк. nowrap - (по умолчанию) запрещён, wrap –  разрешен, wrap-reverse .
justify-content:  – выравнивание вдоль главной оси. значения: flex-start center  flex-end  space-between  space-around  space-evenly
align-items: - выравнивание вдоль поперечной оси. значения: center  flex-start  flex-end  baseline  stretch (умолч)- растягивает на всю высоту или высоту самого высокого элемента.
align-self: перезаписывает align-items: для конкретного элемента. значения: те же что и для align-items
align-content: - выравнивание РЯДОВ (2 ряда например с переносом или 3 ) вдоль поперечной оси. Значения: flex-start   center   flex-end   space-between   space-around   pace-evenlyт   stretch (умолч)   
order: – меняет порядок вывода элементов. задавать всем элементам.
flex-basis: - задаёт базовый размер флекс-элемента вдоль главной оси.
flex-grow: - «коэффициент флекс-жадности» флекс-элемента относительно базового размера. разрешенло увеличиваться
flex-shrink:  - коэф. уменьшения объектов чем базовый размер (1 по умолч. раздешено станов меньше)
flex:{ flex-grow flex-shrink flex-basis }  flex: 0 1 300px;
row-gap: и column-gap: задает отступы между строками и столбцами.
margin: auto флекс-элемент уменьшит свой размер под содержимое и отцентруется по вертикали и горизонтали. внешние отступы не схлопываются и не выпадают
flex: 1 1 0; - хак для флексЭлемента  выравнивает ширину у всех элементов

::before  ::after   строчные эл.. можем применить любые стили. 
::first-line   срабатывает для блочных элементов.  
::placeholder  текст подсказки задаётся  placeholder у тега <input>
::marker    любой элемент со свойством display: list-item

$text: "IT forever." !default;   default  присваивает значение по умолчанию переменным ($) , у которых ещё нет значения            #text применяем переменную
&  явно указать, где должен быть вставлен родительский селектор. (однозначно подставляет  родителя )  &:hover    амперсанд был компилирован в название родительского элемента . с помощью & мозможно сделать .c1.c2 – элементы одновременно с двумя классами c1 и c2  (запись без пробела)
@mixinИМЯ() {}    -создать    @includeИМЯ()  -  вставить    Миксины могут также содержать селекторы, в том числе со свойствами. А селекторы могут содержать ссылки на родительский элемент через амперсанд (&)
%ИМЯ{свойства}    @extend %ИМЯ  шаблоны 

transform  не влияет не соседние эл. не работает с табличными и строчными эл.  transform создаётся новый контекст наложения position: fixed или position: absolute позиционионируются относительно этого эл.  transform: перечисляем свойства через пробел
translateX(X), translateY(Y), translateZ(Z)  смещение вверх-вниз или влево-вправо. позиционируется относительно соответствующих сторон родителя. если задаем % то вычисляются от размера самого блока. 
scaleX(X), scaleY(Y), scaleZ(Z)  масштабирование элемента.  
skewX(X), skewY(Y)   наклон, величина зависит от положения точки применения трансформаций (transform-origin)
rotateX(X), rotateY(Y), rotateZ(Z)  вращение. 
perspective()    принимает один параметр — расстояние до точки схождения перспективы. Она должна быть первой среди всех значений.  transform: perspective(500px) translate3d(10px, 0, 20px) rotateY(3deg);
rotate , translate , scale   это отдельные свойства трансформации . пишем без transform:  и они не перезапишут весь  transform: а перепишут rotate , translate , scale  внутри  transform:
transform-origin  положение точки, относительно которой применяются трансформации.
transform-style    определяет, как будут вести себя потомки элемента в 3D-пространстве при трансформации.
transform-box  определяет область элемента к которой применяются трансформации.
perspective  определяет расстояние от пользователя до задней стенки экрана по оси z
backface-visibility  правляет видимостью задней части элемента, если он поворачивается относительно пользователя с помощью свойства transform    visible — задняя сторона элемента видна (значение по умолчанию).  hidden — задняя сторона элемента не видна.
will-change  позволяет заранее сообщить браузеру об изменениях (анимация, перемещение и т.д), которые могут произойти с элементом.

@keyframes имя анимации { from{} 50%{} to{}} 
animation-name: имя анимации       этот уже пишем нутри элемента с классом или тегом или селектором      none отключить анимацию .element:hover { animation: none; }
animation-duration   пропишем длительность одного цикла анимации.
animation-iteration-count    сколько раз анимация будет проигрываться.   infinite анимация будет повторяться бесконечно. 
animation-direction     сообщает браузеру, должна ли анимация проигрываться в обратном порядке.
animation-fill-mode сообщает браузеру, нужно ли применять стили ключевых кадров до или после проигрывания анимации.
animation-timing-function можно задать, как будет развиваться анимация между ключевыми кадрами (функции)
animation-delay   задаёт задержку воспроизведения анимации.
animation-play-state   позволяющее ставить анимацию на паузу и запускать снова.
animation-timing-function   задает, как будет развиваться анимация между ключевыми кадрами: равномерно, или
Есть возможность применить к одному элементу сразу несколько анимаций. нужно перечислить несколько значений через запятую. нимации будут воспроизводиться одновременно.  

transition    это шорткат перечисляем через пробел свойства и верез запятую возможно писать еще набор свойств.  когда нам нужно плавно изменить CSS-свойства между двумя состояниями элемента. Например, при наведении мышкой.
transition-property — указываем свойство, которое хотим плавно изменить;        transition-property:        color,   font-size;    можно перечислять через запятую 
transition-duration — длительность перехода;                                    transition-duration:        0.1s,    15s;          можно перечислять через запятую
transition-timing-function — функция, описывающая скорость изменения свойства;  transition-timing-function: ease,    step-start,   можно перечислять через запятую
transition-delay — задержка перед началом изменения.                            transition-delay:           0.5s,    0s            можно перечислять через запятую
Если мы хотим плавно изменить два и более свойств, нужно просто перечислить их через запятую.  transition: background-color 0.6s, transform 0.5s;
свойство transition мы задали в стилях для базового состояния (можно задать и ховеру тоже тогда анимация пойдет от ховера до нормального состояния  ). можно плавно изменять любое свойство, у которого значение записывается с помощью чисел. 
Старайтесь использовать для анимации в первую очередь свойства transform и opacity — они самые производительные, потому что не приводят к перезапуску процессов Layout и Paint












вопрос в настоящее время используют такие теги как <em> и как их воспринимает голововые помошники например алиса и пр.,.
вопрос в нстт время <strong> как то помогает продвижению в поисковых системах например яндекс          <b> <i> <u>
вопрос как добавлять многострочный html код в видимую часть браузера
не работает  download   


