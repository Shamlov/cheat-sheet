https://www.responsivebreakpoints.com/    Генератор отзывчивых (responsive) тегов и картинок
https://www.flaticon.com/                 Иконки
https://placekitten.com/                  Сайт с котиками
https://placehold.co/                     Шаблонные (плейсхолдер) картинки
https://inkscape.org/                     Векторный редактор
https://caniuse.com/                      Проверка поддержки свойств
https://www.fontconverter.io/en           конвертируем шрифт    в css шрифта пишем адекватное название задаем font-style: ; font-weight: 

Alt+Z            Переключить перенос текста
Ctrl + /         Закомментировать код
Shift + Alt + F  Pritter
Alt              Множественный ввод
проб + Ctrl      Подсказка
Ctrl + d         Обернуть в тег
Ctrl + h         найти и заменить
Ctrl + Alt + T   перевод


[header nav] [main section] aside footer
div – элементы с таким тегом.                  <div></div> выберет все div
#id – элемент с данным id.                     <div id="languages"></div>
.class – элементы с таким классом.             <div class="languages"></div>
[name="value"] – селекторы на атрибут          В правилах важен регистр букв (строчные/заглавные) 
            [attr] – атрибут установлен,
            [attr="val"] – атрибут равен val.      <input type="checkbox">      input[type="checkbox"]
            [attr^="val"] – атрибут начинается с val, например "value".
            [attr$="lue"] - атрибут заканчивается на lue, например "value"   удобно проверять расшитения 
            [attr|="val"] – атрибут равен val или начинается с val- (дифис), например равен "val-1"
            [attr*="val"] – атрибут содержит подстроку (в слове) val, например равен "myvalue".
            [attr~="val"] – атрибут содержит val как одно из значений через пробел.
:visited – «псевдоклассы», остальные разные условия на элемент 
.c1.c2 – элементы одновременно с двумя классами c1 и c2  (запись без пробела)
p.class - элемент одновременно с <p> и .class как выше только можно группировать так и id теги классы *  без пробела
a#id.c1.c2:visited – элемент a с данным id, классами c1 и c2, и псевдоклассом visited
div p – элементы p, являющиеся потомками div
div > p – только непосредственные потомки (первый уровень детей)
div ~ p – правые соседи: все p на том же уровне вложенности (не родитель и ребенок) !!!, которые идут после div.   (выбирает всех братьев и сестер, справа от div можно не соседей)
div + p – выберет всех правый соседей: p на том же уровне вложенности( не родитель и ребенок)!!!, который идёт сразу после div (если есть).выбирает которые идут друг за другом . (прием li+li выберет li кроме первого ) 

:first-child – первый потомок своего родителя.       .class li:last-child  запись равим образом . т.е. первый li в списке c .class   если li не указать, то просто выберет первый элемент в указанном классе . если нет первого li, то не выберет ничего. 
:last-child – последний потомок своего родителя.     .class li:last-child  запись равим образом . т.е. последний li в списке c .class 
:only-child – единственный потомок своего родителя, соседних элементов нет.
:nth-child(a) – потомок номер a своего родителя, например :nth-child(2) – второй потомок. Нумерация начинается с 1.
:nth-child(an+b) – расширение предыдущего селектора через указание номера потомка формулой, где a,b – константы, а под n подразумевается любое целое число.   например 3n применится к каждому 3-му элементу , а   +1  с какого элемента стартуем (с 1-ого). отсчет начинается не с первого а от первого (3n+1 выберет 1-й 4-й и тд)
:nth-last-child(a), :nth-last-child(an+b) – то же самое, но отсчёт начинается с конца, например :nth-last-child(2) – второй элемент с конца.
:first-of-type  :last-of-type  :only-of-type  :nth-of-type  :nth-last-of-type  на этом же уровне вложенности по типу селектора(тега или класса и пр.). Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:                    li:first-of-type  выберет первый li даже если перед ним другие теги
:not(селектор) – все, кроме подходящих под селектор.         <input type="checkbox" checked>    input[type="checkbox"]:not([checked])  не выберет его   .  li:not(:last-child):not(.active) можнописать составные (выберет все кроме последнего и кроме .active) . нельзя вкладывать :not(:not)
:focus – в фокусе.
:hover – под мышью.
:empty – без детей (даже без текстовых).
:checked, :disabled, :enabled – состояния INPUT.
:target – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.

больший приоритет у элемента нежели у родителя. стили в html самый высокий приоритет <p style =" "></p>
:is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок.
Селектор	                        Вес      калькулятор специфичности https://polypane.app/css-specificity-calculator/#selector=      https://specificity.keegan.st/        https://www.codecaptain.io/tools/css-specificity-calculator
#some	(id)                       1.0.0     селектор по ID
.class или (attr, pseudo-class)    0.1.0     класс, атрибут,псевдокласс      нарастить класс (.tomato) им самим же. Класс можно продолжать наращивать, пока вам не хватит специфичности (.tomato.tomato.tomato)
<span>   (elem, pseudo-elem)       0.0.1     тег или псевдоэлемент
+  >  ~  *  :where()               0.0.0     +, >, ~, универсальный селектор * и псевдокласс :where() веса не имеют.

counter-reset: step 0    counter-increment: step 1 ;      counter(step)                content: counter(step) "."     тут выводим переменную в псевлоэлемент в кавычках можем добавить дополнительный тектс

element::before {
    content: "";
    display: block;
    height: 30px;
    background-image: url("");
    background-size: contain;                 
    background-repeat: no-repeat;
    background-position: center;   }z

Блок__элем_модиф  блок используем многократно, не задаем внешних отступов. элемент неотемлемая часть текущего блока. элементу возможно задавать через дефис имена родители и затем свое имя. блоки вкладываются в другие блоки и добавляется класс.  модификатор можно добавить и блоку и элементу. у модификатора возможно добавить еще параметры. 

родитель img{                                                        img{
    position: relative;                                                 width: 100%;   
    overflow: hidden;                                                   height: 100%;        
    padding-top: 40%; падинг на на месте картинки                       object-fit: cover;         
}                                                                       position: absolute;
                                                                        top: 0;
                                                                        left: 0;  }

position: relative  top, right, bottom, left  z-index  не выпадает из потока
absolute;  top, right, bottom, left  z-index            выпадает из потока. уменьшается под контент.  родителю position: relative   или absolute или fixed и он позичионируется относительно него. margin абсолютно позиционированных блоков не схлопываются. 
fixed    выпадает из потока. уменьшается под контент. позиционирование отпосительно окна браузера. фиксирует на странице(не скролица).
sticky сперва как обычно. при скроле прилепает к верхней границы окна браузера
absolute или fixed можно натянуть на родитель указав задав одновременно противоположные свойства (left и right, или top и bottom) (inset). будет работать, если width и height будут иметь значение auto
приоритет отдаётся свойству left и top

flex-direction: – главная ось, значения: row  column  row-reverse  column-reverse.
flex-wrap: -  перенос строк. nowrap - (по умолчанию) запрещён, wrap –  разрешен, wrap-reverse .
justify-content:  – выравнивание вдоль главной оси. значения: flex-start center  flex-end  space-between  space-around  space-evenly
align-items: - выравнивание вдоль поперечной оси. значения: center  flex-start  flex-end  baseline  stretch (умолч)- растягивает на всю высоту или высоту самого высокого элемента.
align-self: перезаписывает align-items: для конкретного элемента. значения: те же что и для align-items
align-content: - выравнивание РЯДОВ (2 ряда например с переносом или 3 ) вдоль поперечной оси. Значения: flex-start   center   flex-end   space-between   space-around   pace-evenlyт   stretch (умолч)   
order: – меняет порядок вывода элементов. задавать всем элементам.
flex-basis: - задаёт базовый размер флекс-элемента вдоль главной оси.
flex-grow: - «коэффициент флекс-жадности» флекс-элемента относительно базового размера. разрешенло увеличиваться
flex-shrink:  - коэф. уменьшения объектов чем базовый размер (1 по умолч. раздешено станов меньше)
flex:{ flex-grow flex-shrink flex-basis }  flex: 0 1 300px;
row-gap: и column-gap: задает отступы между строками и столбцами.
margin: auto флекс-элемент уменьшит свой размер под содержимое и отцентруется по вертикали и горизонтали. внешние отступы не схлопываются и не выпадают
flex: 1 1 0; - хак для флексЭлемента  выравнивает ширину у всех элементов

::before  ::after   строчные эл.. можем применить любые стили. 
::first-line   срабатывает для блочных элементов.  
::placeholder  текст подсказки задаётся  placeholder у тега <input>
::marker    любой элемент со свойством display: list-item

$text: "IT forever." !default;   default  присваивает значение по умолчанию переменным ($) , у которых ещё нет значения            #text применяем переменную
&  явно указать, где должен быть вставлен родительский селектор. (однозначно подставляет  родителя )  &:hover    амперсанд был компилирован в название родительского элемента . с помощью & мозможно сделать .c1.c2 – элементы одновременно с двумя классами c1 и c2  (запись без пробела)
@mixinИМЯ() {}    -создать    @includeИМЯ()  -  вставить    Миксины могут также содержать селекторы, в том числе со свойствами. А селекторы могут содержать ссылки на родительский элемент через амперсанд (&)
%ИМЯ{свойства}    @extend %ИМЯ  шаблоны 

transform  не влияет не соседние эл. не работает с табличными и строчными эл.  transform создаётся новый контекст наложения position: fixed или position: absolute позиционионируются относительно этого эл.  transform: перечисляем свойства через пробел
translateX(X), translateY(Y), translateZ(Z)  смещение вверх-вниз или влево-вправо. позиционируется относительно соответствующих сторон родителя. если задаем % то вычисляются от размера самого блока. 
scaleX(X), scaleY(Y), scaleZ(Z)  масштабирование элемента.  
skewX(X), skewY(Y)   наклон, величина зависит от положения точки применения трансформаций (transform-origin)
rotateX(X), rotateY(Y), rotateZ(Z)  вращение. 
perspective()    принимает один параметр — расстояние до точки схождения перспективы. Она должна быть первой среди всех значений.  transform: perspective(500px) translate3d(10px, 0, 20px) rotateY(3deg);
rotate , translate , scale   это отдельные свойства трансформации . пишем без transform:  и они не перезапишут весь  transform: а перепишут rotate , translate , scale  внутри  transform:
transform-origin  положение точки, относительно которой применяются трансформации.
transform-style    определяет, как будут вести себя потомки элемента в 3D-пространстве при трансформации.
transform-box  определяет область элемента к которой применяются трансформации.
perspective  определяет расстояние от пользователя до задней стенки экрана по оси z
backface-visibility  правляет видимостью задней части элемента, если он поворачивается относительно пользователя с помощью свойства transform    visible — задняя сторона элемента видна (значение по умолчанию).  hidden — задняя сторона элемента не видна.
will-change  позволяет заранее сообщить браузеру об изменениях (анимация, перемещение и т.д), которые могут произойти с элементом.
rotate, translate  scale   указав эти свойства без ключевого слова transform . тогда не важно в каком порядке перечисляем трансформации, результат будет одинаков. и они не перезаписывают другие свойства transform
конечное положение элемента отличается в зависимости от порядка перечисления свойств трансформации через transform . 


@keyframes имя анимации { from{} 50%{} to{}} 
animation-name: имя анимации       этот уже пишем нутри элемента с классом или тегом или селектором      none отключить анимацию .element:hover { animation: none; }
animation-duration   пропишем длительность одного цикла анимации.
animation-iteration-count    сколько раз анимация будет проигрываться.   infinite анимация будет повторяться бесконечно. 
animation-direction     сообщает браузеру, должна ли анимация проигрываться в обратном порядке.
animation-fill-mode сообщает браузеру, нужно ли применять стили ключевых кадров до или после проигрывания анимации.
animation-timing-function можно задать, как будет развиваться анимация между ключевыми кадрами (функции)
animation-delay   задаёт задержку воспроизведения анимации.
animation-play-state   позволяющее ставить анимацию на паузу и запускать снова.
animation-timing-function   задает, как будет развиваться анимация между ключевыми кадрами: равномерно, или
Есть возможность применить к одному элементу сразу несколько анимаций. нужно перечислить несколько значений через запятую. нимации будут воспроизводиться одновременно.  

transition    это шорткат перечисляем через пробел свойства и верез запятую возможно писать еще набор свойств.  когда нам нужно плавно изменить CSS-свойства между двумя состояниями элемента. Например, при наведении мышкой.
transition-property — указываем свойство, которое хотим плавно изменить;        transition-property:        color,   font-size;    можно перечислять через запятую 
transition-duration — длительность перехода;                                    transition-duration:        0.1s,    15s;          можно перечислять через запятую
transition-timing-function — функция, описывающая скорость изменения свойства;  transition-timing-function: ease,    step-start,   можно перечислять через запятую
transition-delay — задержка перед началом изменения.                            transition-delay:           0.5s,    0s            можно перечислять через запятую
Если мы хотим плавно изменить два и более свойств, нужно просто перечислить их через запятую.  transition: background-color 0.6s, transform 0.5s;
свойство transition мы задали в стилях для базового состояния (можно задать и ховеру тоже тогда анимация пойдет от ховера до нормального состояния  ). можно плавно изменять любое свойство, у которого значение записывается с помощью чисел. 
Старайтесь использовать для анимации в первую очередь свойства transform и opacity — они самые производительные, потому что не приводят к перезапуску процессов Layout и Paint

inherit  -  значение свойства нужно найти у ближайшего родительского элемента (или выше) и унаследовать его для текущего элемента.  Если значения нет, то браузер применит свои стили, а если и браузерных стилей нет, то тогда будет применено значение initial
initial  -  сбрасывает все указанные значения свойства для конкретного блока до значений по умолчанию. (не браузерных) это не значение, заданное браузером, а значение по умолчанию для элемента HTML, определённое в спецификации CSS.
unset    -  работает так же, как и inherit для наследуемых свойств.   ненаследуемых свойств ведет себя как initial, то есть применится значение по умолчанию.  есть свойство all, которое дает нам новую возможность — сбросить наследуемые и ненаследуемые свойства одновременно. Это единственная причина существования нового ключевого слова unset! В противном случае мы могли бы вместо этого использовать inherit и initial.
revert   -  сбрасывает до базовых стилей браузера

display: grid;  display: inline-grid;
grid   Мегашорткат, позволяющий задать значения всему и сразу
grid-template-columns, grid-template-rows   задают размеры и количество колонок или рядов грид-раскладки. grid-template-columns: [start] 2fr [line2] 400px [line3] 600px [end];
grid-template   ряды/колонки  шорткат  grid-template: repeat(4, 1fr) / repeat(3, 500px);
[line2 col2-start]   Каждая линия может иметь больше одного имени
repeat()    grid-template-columns: repeat(3, 250px); Будет создано 3 колонки по 250 пикселей. 
fr   отвечает за свободное пространство внутри грид-контейнера. Свободное пространство рассчитывается после того, как место отдано всем фиксированным размерам.
auto-fill и auto-fit  когда количество колонок или строк не известно для свойств grid-template-columns и grid-template-rows
auto-fill стремится заполнить колонками всё доступное пространство,  grid-template-columns: repeat(auto-fill, minmax(100px 1fr))
auto-fit  схлопывает пустые колонки и отдаёт больше места под заполненные.
grid-auto-columns, grid-auto-rows  Если элементов внутри грид-контейнера больше, чем может поместиться то создают автоматические, неявные ряды и колонки. можно управлять размерами этих автоматических рядов и колонок.  grid-auto-rows: 40px;
grid-auto-flow  (умол. row column  dense - комбинируем )  grid-auto-flow: row dense; Если грид-элементов больше, чем явно объявленных колонок или рядов, то они автоматически размещаются внутри родителя
grid-template-areas (умол. none - не задано имя  . — означает пустую ячейку ) задает шаблон сетки расположения элементов внутри грид-контейнера. Удобнее будет подписывать области в виде некой таблицы.
grid-area   указывает элементу, какую из именованных областей ему нужно занять. grid-area: content;  /* Займёт область content внутри грид-сетки */  .item1 { grid-area: header;} .item2 { grid-area: content;}
grid-area   шорткат row-start / column-start / row-end / column-end, то есть сначала указываем оба начала, а потом оба конца. grid-area: 1 / col4-start / last-line / 6;
row-gap, column-gap  отступы между рядами или колонками.   gap: 50px 20px;   gap: ряды колонки;
justify-content  ( start end center stretch space-around  space-evenly space-between )  выровнять элементы вдоль оси строки (в родителе грида). выровнять его столбцы слева или справа.
justify-items  ( start end center stretch)   выравнивание грид-элементов внутри по горизонтальной оси. выравнивание внутри самого элемента (выравнивание элемента уже в ребенке грида)
justify-self  ( start end center stretch)  установить горизонтальное выравнивание для отдельного элемента, 
align-items  ( start end center stretch)  выровнять элементы по вертикальной оси внутри (выравнивание элемента уже в ребенке грида)
align-self - умол. auto можно использовать для сброса ранее заданных значений. ( start end center stretch) выравнивает отдельный элемент по вертикальной оси. 
place-items  шорткат для align-items и для justify-items
Важное замечание: свойства float, display: inline-block, display: table-cell, vertical-align и column-* не дают никакого эффекта, когда применяются к грид-элементам.
grid-column-start, grid-column-end, grid-row-start, grid-row-end  (умол auto   название или номер линии    span число   span имя )  положение элемента внутри грид-сетки при помощи указания на конкретные направляющие линии.
grid-column, grid-row   шорткаты для grid-column-start, grid-column-end и grid-row-start, grid-row-end соответственно.   grid-column: 3 / span 2;
z-index   для управления контекстом наложения.

fr min-content, max-content и auto  дополнительно доступны еденицы
minmax()  grid-template-columns: minmax(200px, 1fr); колонка займёт 1 часть свободного пространства грид-контейнера, но не меньше 200 пикселей.
доступна анимация у  gap, row-gap, column-gap, grid-template-columns, grid-template-rows. 



вопрос в настоящее время используют такие теги как <em> и как их воспринимает голововые помошники например алиса и пр.,.
вопрос в нстт время <strong> как то помогает продвижению в поисковых системах например яндекс          <b> <i> <u>
вопрос как добавлять многострочный html код в видимую часть браузера
не работает  download   


